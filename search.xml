<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ionic2使用Slides的loop属性后点击事件失效bug]]></title>
    <url>%2F2017%2F05%2F15%2FIonic2%E4%BD%BF%E7%94%A8Slides%E7%9A%84loop%E5%B1%9E%E6%80%A7%E5%90%8E%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%A4%B1%E6%95%88bug%2F</url>
    <content type="text"><![CDATA[问题描述：Ionic2使用Slides的loop=’true’属性后，从slide第一页滑动到最后一页，或者最后一页滑动到第一页，点击事件会失效。 问题原因：只要设置了loop=’true’ ，Slide会默认复制第一页和最后一页，分别放在最后一页后和第一页前，达到循环的效果。由于dom代码clone的原因导致点击事件失效 问题解决：为第一页和最后一页的标签加上class，在dom加载完成后对第一页和最后一页加上事件即可。注意：因为clone后，会有2个标签有相同的class，注意区分，还需要阻止事件冒泡 html：1234&lt;ion-slides #ionSlides loop="true" autoplay="3000" pager id="indexSlides" &gt; &lt;ion-slide&gt;&lt;div class="toReport"&gt;&lt;img src=""/&gt;&lt;/div&gt;&lt;/ion-slide&gt; &lt;ion-slide&gt;&lt;div class="toBusines"&gt;&lt;img src=""/&gt;&lt;/div&gt;&lt;/ion-slide&gt;&lt;/ion-slides&gt; TS：123let toReportBtn:any = document.getElementsByClassName("toReport"); toReportBtn[0].addEventListener("click", (e)=&gt;&#123;this.pushToReport();e.stopImmediatePropagation()&#125;); toReportBtn[1].addEventListener("click", (e)=&gt;&#123;this.pushToReport();e.stopImmediatePropagation()&#125;);]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Slides</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2自定义遮罩层和相关注意事项]]></title>
    <url>%2F2017%2F05%2F04%2FIonic2%E8%87%AA%E5%AE%9A%E4%B9%89%E9%81%AE%E7%BD%A9%E5%B1%82%E5%92%8C%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20%2F</url>
    <content type="text"><![CDATA[1、自定义遮罩层步骤1.1先创建一个展示框，在遮罩层之上123&lt;div class="aboutPage-isShowDiv" *ngIf="isShow"&gt; &lt;h1&gt;放内容&lt;/h1&gt; &lt;/div&gt; 1.2根据alert或者其他组件的样式，抽取ion-backdrop标签出来使用123&lt;div *ngIf="isShow" class="backdrop-div" (click)="backdropclick($event)" ontouchmove="event.preventDefault();event.stopPropagation();"&gt; &lt;ion-backdrop disable-activated role="presentation" tappable style="opacity: 0.5; transition-delay: initial; transition-property: none;"&gt;&lt;/ion-backdrop&gt;&lt;/div&gt; 并为组件添加点击事件（阻止冒泡） 12345678910//遮挡层点击事件 backdropclick(e)&#123; //判断点击的是否为遮罩层，是的话隐藏遮罩层 if(e.srcElement.className != 'itemClass')&#123; this.isShow = false; &#125; //隐藏滚动条 this.hiddenscroll(); e.stopPropagation(); &#125; 并为遮罩层添加触摸事件（阻止冒泡、阻止默认事件 ontouchmove=”event.preventDefault();event.stopPropagation();”） 到此，就完成了Ionic2自定义的遮罩层 2.注意事项2.1 在ios手机上遮罩层能滑动解决方法：为遮罩层添加触摸事件，阻止默认事件，阻止冒泡，另外如果样式有些出入的话，还需要微调一下。 2.2 ios上弹出框上有滑动的列表的话，也会带动底层的列表滑动解决方法： 除了给遮罩层添加触摸事件外，还需在弹出框展示的时候隐藏滚动条（设置overflow=’hidden’），恢复时恢复滚动条即可 12&lt;ion-content id="aboutContent"&gt;&lt;/ion-content&gt; 123456789101112//弹出下拉框时，取消scrollhiddenscroll()&#123; //获取当前组件的ID let aboutContent = document.querySelector(&quot;#aboutContent&quot;); //获取当前组件下的scroll-content元素 let scroll:any = aboutContent.querySelector(&quot;.scroll-content&quot;); if(this.isShow)&#123; scroll.style.overflow=&apos;hidden&apos;; &#125;else &#123; scroll.style.overflow=&apos;&apos;; &#125;&#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>遮罩层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2使用百度地图和html5 geolocation的一些注意事项]]></title>
    <url>%2F2017%2F05%2F04%2FIonic2%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%92%8Chtml5%20geolocation%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[1、完美解决window.navigator.geolocation.getCurrentPosition，在IOS10系统中无法定位问题 目前由于许多用户都将电话升级到了IOS系统，苹果的iOS 10已经正式对外推送，相信很多用户已经更新到了最新的系统。然而，如果web站没有及时支持https协议的话，当很多用户在iOS 10下访问很多网站时，会发现都无法进行正常精确定位，导致部分网站的周边推荐服务无法正常使用。为何在iOS 10下无法获取当前位置信息？这是因为在iOS 10中，苹果对webkit定位权限进行了修改，所有定位请求的页面必须是https协议的。如果是非https网页，在http协议下通过html5原生定位接口会返回错误，也就是无法正常定位到用户的具体位置，而已经支持https的网站则不会受影响。 目前提供的解决方案：1、将网站的http设置为Https。2、通过第三方解决，也就是调用百度地图或者其他地图的定位功能进行定位。调用百度地图方法如下： 12345678910111213141516171819202122232425//获取本机的地址let geolocation = new BMap.Geolocation();geolocation.getCurrentPosition((position)=&gt;&#123; //0代表调用成功，具体状态可见百度地图api if(geolocation.getStatus() == 0)&#123; //经度 let longitude =position.longitude; //纬度 let latitude = position.latitude; let pPoint = new BMap.Point(longitude,latitude); let heading = 0; if(position.heading !=null &amp;&amp; position.heading != '')&#123; heading = position.heading; &#125; let icon = new BMap.Symbol(BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW, &#123; scale: 2, strokeWeight: 1, rotation: heading,//顺时针旋转30度 fillColor: '#1794f6', fillOpacity: 0.8 &#125;); &#125;else &#123; console.log(position); &#125; 2、Ionic2的组件使用百度地图、百度地图矢量的方法Ionic2使用百度地图或者其他地图时除了在index.html引入js外，还需要在相应需要使用的ts文件上加上声明： 12declare var BMap;declare var BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW; 同理，如果需要使用到百度地图的矢量，也要加上声明，如上。 如果多个组件使用到的话，可以在declarations.d.ts文件上全局声明。引入其他js如echart.js等方法雷同]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>geolocation</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2创建一个自定义pipe实现千分位号]]></title>
    <url>%2F2017%2F04%2F09%2FIonic2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89pipe%E5%AE%9E%E7%8E%B0%E5%8D%83%E5%88%86%E4%BD%8D%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[1、在src目录下创建一个pipe目录用于存放自定义pipe，然后创建一个pipe |–src |–pipe *.ts 2、在ts文件里面写pipe的逻辑1234567891011121314151617181920import &#123; Pipe, PipeTransform &#125; from '@angular/core';/* * Raise the value exponentially * Takes an exponent argument that defaults to 1. * Usage: * value | exponentialStrength:exponent * Example: * &#123;&#123; 2 | exponentialStrength:10&#125;&#125; * formats to: 1024 * 将number转换为千分位的字符串 */@Pipe(&#123;name: 'toNumber'&#125;)export class ToNumberPipe implements PipeTransform &#123; //实现了PipeTransform类，实现transform方法，当html使用了toNumber的管道，会自动调用此方法 transform(input:number): string &#123; //这里可以带多个参数，第一个参数默认是原始数据，这里是指 //amount、total 、debt 、overdue ，见下html代码 return input.toString().replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ",");//转为千分位的正则表达式 &#125;&#125; 3、在app.modules.ts中import这个ts文件，然后只需在declarations中声明。4、在需要的Html模版中使用（不需要引入）123456&lt;ul&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].amount | toNumber&#125;&#125;辆&lt;/li&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].total | toNumber&#125;&#125;元&lt;/li&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].debt | toNumber&#125;&#125;辆&lt;/li&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].overdue | toNumber&#125;&#125;元&lt;/li&gt;&lt;/ul&gt; 这样就完成了，amount等数据会传入到transform方法，然后返回的数据展示在li上。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>pipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Ionic2\Angular2使用http的一些坑]]></title>
    <url>%2F2017%2F04%2F09%2F%E5%85%B3%E4%BA%8EIonic2Angular2%E4%BD%BF%E7%94%A8http%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1、服务器接收key=value&amp;key=value类型的值，但服务器无法获取到Post请求的body的值 描述：使用url?key=value&amp;key=value的形式可以正常请求到参数，但是把参数放入到body后，服务器估计获取到信息但无法正确解析 解决：1、body要为字符串，格式：‘key=value&amp;key=value’2、然后发送http请求的时候需要设置下‘Content-Type’: ‘application/x-www-form-urlencoded; charset=UTF-8’ 2、发送登录请求给服务器后，服务器返回cookie，里面含有seesionId，但无法获取到cookie，也无法发送cookie描述：使用angular的post请求后，服务器返回cookie，如下图 但是浏览器中看不到有cookie，也无法获取到这个session值，手动设置cookie，下次发送post时，也不会带上cookie。网上查找，说需要在post请求的option中加上： 1this.http.get('http://my.domain.com/request', &#123; withCredentials: true &#125;) 设置后发现会出现跨域的问题，但已经有cookie存到本地。最后发现使用的googole的插件Allow-Control-Allow-Origin 虽然能进行跨域，但是无法存储和发送cookie 解决：1、禁用了Allow-Control-Allow-Origin2、在本机部署nginx进行跨域，问题解决。可以正常从服务器获取cookie，并发送cookienginx配置：]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2之tabs相关内容和其他一些坑]]></title>
    <url>%2F2017%2F04%2F05%2FIonic2%E4%B9%8Btabs%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E5%92%8C%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1、 ionic2 中隐藏子页面tabs选项卡的三种方法第一种： 隐藏全部子页面的tabs选项界面找到app.module.ts文件 ，修改如下代码 12345imports: [ IonicModule.forRoot(MyApp,&#123; tabsHideOnSubPages: 'true' //隐藏全部子页面tabs &#125;) ], 第二种：隐藏某个子页面的tabs ; 缺点：当子页面使用pop()方法退出时，父页面的任何事件都不响应。 123import&#123; App &#125; from'ionic-angular'; //1.引入App类constructor(privateapp:App) &#123;&#125; //2.声明初始化app对象this.app.getRootNav().push(nextPage); //3.调用this.app.getRootNav() 从根页面跳转就可以了 第三种：隐藏某个子页面的tabs； 缺点：暂无 123456789101112131415161718//当页面进入初始化的时候 letelements = document.querySelectorAll(".tabbar"); if(elements !=null) &#123; Object.keys(elements).map((key) =&gt; &#123; elements[key].style.display ='none'; &#125;); &#125; //当退出页面的时候ionViewWillLeave() &#123; letelements = document.querySelectorAll(".tabbar"); if(elements !=null) &#123; Object.keys(elements).map((key) =&gt; &#123; elements[key].style.display ='flex'; &#125;); &#125;&#125; 2、Ionic2 组件之Tab的基本属性和事件 示例html代码如下: 1&lt;ion-tabs #mainTabs (ionChange)="changeTabs()" color="danger" tabsHighlight="true"&gt; &lt;ion-tab [root]="tab1Root" [rootParams]="homeParams" tabTitle="Home" tabIcon="home"&gt;&lt;/ion-tab&gt; &lt;ion-tab [root]="tab2Root" (ionSelect)="selectFriend()" tabTitle="Friends" tabIcon="aperture" tabBadge="3" tabBadgeStyle="danger"&gt;&lt;/ion-tab&gt; &lt;ion-tab [root]="tab3Root" enabled="false" swipeBackEnabled="true" tabTitle="Contact" tabIcon="contacts"&gt;&lt;/ion-tab&gt; &lt;/ion-tabs&gt; 3、ionic的一些坑1、如何在push页面后隐藏tabbar 在ionicBootstrap中设置tabsHideOnSubPages为true 2、如何设置返回按键文字 在ionicBootstrap中设置backButtonText，如”返回”或”“ 3、如何在page pop后传递参数到前一个页面 a) 使用model来代替push，然后在dismiss方法中传递参数 b) 使用Promise parent: 12345new Promise((resolve, reject) =&gt; &#123; this.nav.push(ChildPage, &#123;resolve: resolve&#125;); &#125;).then(data =&gt; &#123; let value = data["property"]; &#125;); child： 12let resolve = this.navParams.get("resolve"); resolve(&#123;property: value&#125;); 5 . 如何设置button的disabled状态：注意解除disabled状态需要设置绑定变量为null &lt;button disabled=“{{buttonDisabled}}”&gt; this.buttonDisabled = true; this.buttonDisabled = null; 6.如何修改slides的bullet 在slides的option中添加下面两个属性： bulletClass: &quot;my-swiper-pagination-bullet&quot;, bulletActiveClass: &apos;my-swiper-pagination-bullet-active&apos;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>tabs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2实现:下拉刷新和上拉加载]]></title>
    <url>%2F2017%2F04%2F05%2FIonic2%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[下拉刷新：12345678910&lt;ion-content&gt; &lt;ion-refresher (ionRefresh)="doRefresh($event)"&gt; &lt;ion-refresher-content pullingIcon="arrow-dropdown" pullingText="Pull to refresh" refreshingSpinner="circles" refreshingText="Refreshing..."&gt; &lt;/ion-refresher-content&gt; &lt;/ion-refresher&gt;&lt;/ion-content&gt; TypeScript： 12345678910111213141516@Component(&#123;...&#125;) export class NewsFeedPage &#123; items = []; doRefresh(refresher) &#123; console.log(&apos;Begin async operation&apos;, refresher); setTimeout(() =&gt; &#123; this.items = []; for (var i = 0; i &lt; 30; i++) &#123; this.items.push( this.items.length ); &#125; console.log(&apos;Async operation has ended&apos;); refresher.complete(); &#125;, 2000); &#125; &#125; 上拉加载：1234567891011121314&lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-item *ngFor="let i of items"&gt;&#123;&#123;i&#125;&#125;&lt;/ion-item&gt; &lt;/ion-list&gt; &lt;ion-infinite-scroll (ionInfinite)="doInfinite($event)"&gt; &lt;ion-infinite-scroll-content loadingSpinner="bubbles" loadingText="Loading more data..."&gt; &lt;/ion-infinite-scroll-content&gt; &lt;/ion-infinite-scroll&gt;&lt;/ion-content&gt; TypeScript： 123456789101112131415161718192021222324@Component(&#123;...&#125;)export class NewsFeedPage &#123; items = []; constructor() &#123; for (let i = 0; i &lt; 30; i++) &#123; this.items.push( this.items.length ); &#125; &#125; doInfinite(infiniteScroll) &#123; console.log('Begin async operation'); setTimeout(() =&gt; &#123; for (let i = 0; i &lt; 30; i++) &#123; this.items.push( this.items.length ); &#125; console.log('Async operation has ended'); infiniteScroll.complete(); &#125;, 500); &#125;&#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>refesh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2关于Slides的一些坑]]></title>
    <url>%2F2017%2F04%2F05%2FIonic2%E5%85%B3%E4%BA%8ESlides%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[首先，要知道Slides是实际使用的是swiper组件，所以遇到问题也可以查阅swiper相关资料。 通用Html代码 1&lt;ion-slides #ionSlides loop="true" autoplay="3000" pager (ionSlideAutoplayStop)="autoPlay()"&gt; TS: 1@ViewChild('ionSlides') slides; 1、Slides在用户拖拽后，停止自动播放，解决方法：第一种方法： 可以监听 停止自动播放 事件，然后开启自动播放： 12autoPlay()&#123; this.slides.startAutoplay(); 第二种方法： 在启动的时候设置 slides的属性autoplayDisableOnInteraction 为false； 123ionViewDidEnter()&#123; this.slides.autoplayDisableOnInteraction = false; &#125; 2、自动播放的Slides调转到其他页面一定时间后（超过设置的播放时间），再回到此页面，自动播放失效，解决方法如下： 现在页面退出的时候手动停止slides的播放（此步骤必须要有，不然后面的启动无效），在回来页面加载完成的时候启动自动播放，代码如下： 12345678910 //页面进入时启动自动播放 ionViewDidEnter()&#123; this.slides.startAutoplay(); &#125; //页面离开时停止自动播放 ionViewDidLeave()&#123; this.slides.stopAutoplay(); &#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Slides</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)Activity的Launch mode详解 singleTask正解]]></title>
    <url>%2F2017%2F03%2F13%2F(%E8%BD%AC)Activity%E7%9A%84Launch%20mode%E8%AF%A6%E8%A7%A3%20singleTask%E6%AD%A3%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文参考了此文http://hi.baidu.com/amauri3389/blog/item/a54475c2a4b2f040b219a86a.html另附 android task与back stack开发文档翻译参见：http://mypyg.iteye.com/blog/919643 http://blog.csdn.net/infsafe/article/details/5666964 Activity有四种加载模式：standard(默认)， singleTop， singleTask和 singleInstance。以下逐一举例说明他们的区别： standard：Activity的默认加载方法，即使某个Activity在Task栈中已经存在，另一个activity通过Intent跳转到该activity，同样会新创建一个实例压入栈中。例如：现在栈的情况为：A B C D，在D这个Activity中通过Intent跳转到D，那么现在的栈情况为： A B C D D 。此时如果栈顶的D通过Intent跳转到B，则栈情况为：A B C D D B。此时如果依次按返回键，D D C B A将会依次弹出栈而显示在界面上。 singleTop：如果某个Activity的Launch mode设置成singleTop，那么当该Activity位于栈顶的时候，再通过Intent跳转到本身这个Activity，则将不会创建一个新的实例压入栈中。例如：现在栈的情况为：A B C D。D的Launch mode设置成了singleTop，那么在D中启动Intent跳转到D，那么将不会新创建一个D的实例压入栈中，此时栈的情况依然为：A B C D。但是如果此时B的模式也是singleTop，D跳转到B，那么则会新建一个B的实例压入栈中，因为此时B不是位于栈顶，此时栈的情况就变成了：A B C D B。 singleTask：如果某个Activity是singleTask模式，那么Task栈中将会只有一个该Activity的实例。例如：现在栈的情况为：A B C D。B的Launch mode为singleTask，此时D通过Intent跳转到B，则栈的情况变成了：A B。而C和D被弹出销毁了，也就是说位于B之上的实例都被销毁了。 关于singleTask这个网上颇有争议，google api说singTask模式只能启动一个task，且总是位于栈底，这个也不是完全正确 分2种情况： 1、如果在同一个应用(apk)中使用singleTask，刚不在栈底，对应于下面的情况一 2、如果从不同应用启动一个singleTask的activity，刚依赖于此activity所在的栈，如果之前没有运行过，则新建栈处于栈底，如果有运行过，则有可能不在栈底，对应于情况二 情况一：如果在本程序中启动singleTask的activity：假设ActivityA是程序的入口，是默认的模式（standard）,ActivityB是singleTask 模式，由ActivityA启动，刚ActivityB不会位于栈底，不是根元素，不会启动新的task，此种情况ActivityB会和ActivityA在一个栈中，位于ActivityA上面 情况二：如果ActivityB由另外一个程序启动：假设apkA是情况一中的应用，apkB是另外一个测试程序，在apkB中启动apkA中的ActivityB，再分两种情况，如果ActivityB未启动过，刚ActivityB会位于栈底，是根元素，会启动新的task；如果ActivityB启动过，则ActivityB保持原来的位置不变，在栈底或者栈顶，移除掉ActivityB之上所有的activity(如果有)，见下图 此图就是保存了activitY所在的栈的情况，按返回键的时候，会首先依次移除掉activitY所在的栈的activity，然后才是activity2的 注意：singleTask模式的Activity不管是位于栈顶还是栈底，再次运行这个Activity时，都会destory掉它上面的Activity来保证整个栈中只有一个自己，切记切记 singleInstance：将Activity压入一个新建的任务栈中。例如：Task栈1的情况为：A B C。C通过Intent跳转到D，而D的Launch mode为singleInstance，则将会新建一个Task栈2。此时Task栈1的情况还是为：A B C。Task栈2的情况为：D。此时屏幕界面显示D的内容，如果这时D又通过Intent跳转到D，则Task栈2中也不会新建一个D的实例，所以两个栈的情况也不会变化。而如果D跳转到C，则栈1的情况变成了：A B C C，因为C的Launch mode为standard，此时如果再按返回键，则栈1变成：A B C。也就是说现在界面还显示C的内容，不是D。 好了，现在有一个问题就是这时这种情况下如果用户点击了Home键，则再也回不到D的即时界面了。如果想解决这个问题，可以为D在Manifest.xml文件中的声明加上： 1234567&lt;intent-filter&gt; &lt;action Android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; 加上这段之后，也就是说该程序中有两个这种声明，另一个就是那个正常的根activity，在打成apk包安装之后，在程序列表中能看到两个图标，但是如果都运行的话，在任务管理器中其实也只有一个。上面的情况点击D的那个图标就能回到它的即时界面（比如一个EditText，以前输入的内容，现在回到之后依然存在）。 PS：intent-filter中 和 两个过滤条件缺一不可才会在程序列表中添加一个图标，图标下的显示文字是android:label设定的字符串。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic2点击事件感觉到延迟的解决办法]]></title>
    <url>%2F2016%2F12%2F14%2Fionic2%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%84%9F%E8%A7%89%E5%88%B0%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[In general, we recommend only adding (click) events to elements that are normally clickable. This includes &lt; button&gt; and &lt; a&gt; elements. This improves accessibility as a screen reader will be able to tell that the element is clickable.However, you may need to add a (click) event to an element that is not normally clickable. When you do this you may experience a 300ms delay from the time you click the element to the event firing. To remove this delay, you can add the tappable attribute to your element. 1&lt;div tappable (click)="doClick()"&gt;I am clickable!&lt;/div&gt; 一般来说，我们建议您只向通常可点击的元素添加（点击）事件。 这包括&lt; button&gt;和&lt; a&gt;元素。 这提高了可访问性，因为屏幕阅读器将能够告诉该元素是可点击的。 但是，您可能需要向通常不可点击的元素添加（点击）事件。 执行此操作时，您可能会遇到从点击元素到事件触发的300毫秒延迟。 要删除此延迟，可以将tappable属性添加到元素。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>tappable</tag>
        <tag>点击延迟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular2的http请求返回结果的subcribe注意事项]]></title>
    <url>%2F2016%2F10%2F27%2Fangular2%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84subcribe%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[1234567891011121314mData:anythis.monitorSer.getVehicleLonAndLat(vehicleIds) .subscribe( data =&gt; &#123; //将data下的data存放到mData中 this.mData=JSON.parse(data.data); //功能实现 this.init(); &#125;, error =&gt; this.errorMessage = &lt;any&gt;error);//错误处理 subscribe()异步处理，如果需要用返回的数据，在返回函数里面将数据存入成员变量，并作相应的处理]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2可以有两种方式来存储数据，Local Storage和SQLite]]></title>
    <url>%2F2016%2F10%2F27%2FIonic2%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%8CLocal%20Storage%E5%92%8CSQLite%2F</url>
    <content type="text"><![CDATA[Ionic2可以有两种方式来存储数据，Local Storage和SQLiteLocalStorage 因为比较容易访问，所以不适合存比较敏感性的数据 比如可以存储: 用户是否登录的信息. 一些session信息等 具体用法： 进入项目目录：cd MyFirstApp在主页设置一个按钮，点击按钮，获取LocalStorage的数据并打印在控制台 app/pages/home/home.html 在app/pages/home/home.ts中增加一个处理方法： 我们可以通过 this.local = new Storage(LocalStorage); this.local.set(‘isLogin’, false); 来设置并保存isLogin的值 并且通过： this.local.get(‘isLogin’); 来获取isLogin的值 此上方法目前使用较少，可以用HTML5的LocalStorage代替 localstorage.setItem(‘…’,’…’); localstorage.getItem(‘…’); localstorage注意事项：1、localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。2、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性3、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换4、localStorage在浏览器的隐私模式下面是不可读取的5、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡6、localStorage不能被爬虫抓取到localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空 SQLite我们还可以通过SQLite来存储数据，通过SQL语句来实现相关存储。 首先我们必须增加一个插件：进入项目目录：cd MyFirstApp 运行：ionic plugin add https://github.com/litehelpers/Cordova-sqlite-storage在app/app.ts中，我们先初始化一些数据库信息： 在app/pages/home/home.html中增加一个按钮和一个Label，点击按钮，将数据库dbname6中people这个表的第一条记录的firstname字段展示出来： app/pages/home/home.html 在app/pages/home/home.ts中增加相应的方法来获取数据库中的数据： 运行：ionic serve -l 点击ShowData按钮：]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Local</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在chrome浏览器上出现此错误ERR_BLOCKED_BY_CLIENT]]></title>
    <url>%2F2016%2F10%2F27%2F%E5%9C%A8chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AD%A4%E9%94%99%E8%AF%AFERR_BLOCKED_BY_CLIENT%2F</url>
    <content type="text"><![CDATA[在 chrome浏览器上出现此错误，一般都是安装有拦截广告的插件，把此功能给拦截了 I had faced the similar error, it is basically caused when use the ad blockers.Turn them off, and you run it easily.]]></content>
      <categories>
        <category>Ionic2</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>ERR_BLOCKED_BY_CLIENT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2(Angular)中使用Rxjs的Observeble]]></title>
    <url>%2F2016%2F10%2F27%2FIonic2(Angular)%E4%B8%AD%E4%BD%BF%E7%94%A8Rxjs%E7%9A%84Observeble%2F</url>
    <content type="text"><![CDATA[如下一样，需要为handleError 添加private ，不加或者为public的话， ionic serve 不会报错，但是ionic build ios 会出错。 12345678910111213private extractData(res: Response) &#123; let body = res.json(); console.info(res.json()); return body|| &#123; &#125;;&#125;private handleError (error: any) &#123; // In a real world app, we might use a remote logging infrastructure // We'd also dig deeper into the error to get a better message let errMsg = (error.message) ? error.message : error.status ? `$&#123;error.status&#125; - $&#123;error.statusText&#125;` : 'Server error'; console.error(errMsg); // log to console instead return Observable.throw(errMsg);&#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Observeble</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic2页面的生命周期]]></title>
    <url>%2F2016%2F10%2F27%2Fionic2%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Windows下使用ionic打包与开发IOS程序]]></title>
    <url>%2F2016%2F09%2F21%2F%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8B%E4%BD%BF%E7%94%A8ionic%E6%89%93%E5%8C%85%E4%B8%8E%E5%BC%80%E5%8F%91IOS%E7%A8%8B%E5%BA%8F%20%2F</url>
    <content type="text"><![CDATA[开发iOS程序需要mac本，没的话就只能在虚拟机上安装一个MacOS以下为步骤： 1、安装VMware和Mac OS 参考网上教程 2、ionic开发ios程序 3、安装Xcode 为什么要安装Xcode呢？ ionic开发Android程序都不需要安装eclipse等IDE，只要一个能写CSS，JS ，HTML的IDE就行（Hbuilder，WebStrom，Sublime Text）， 开发完成之后不就执行个ionic platform add android,ionic build android，然后就能生成一个.apk文件，给手机上一安装O了。 ionic开发ios程序就得安装Xcode IDE，这是因为蛋疼的ios程序无法直接使用命令生成，使用命令只能生成.project文件，然后再使用Xcode IDE将.project文件转成.ipa文件，更让人蛋疼的是这个ipa文件居然也不能被直接安装到爱疯上，只能先上传到APP Store，人家审核通过之后，我们再从APP Store上下载。（看到这你可能快疯了，但是没法啊，谁让人家NB呢。好了废话少说了，乖乖安装Xcode吧） 4、安装ionic开发环境 （这个和在windows上安装android开发环境类似） 5、安装Nodejs 百度下载，傻瓜式安装，注意：你现在是Mac本，所以需要下载Nodejs for mac的，别下错了 6、安装cordova,ionic 1234sudo npm install -g cordova sudo npm install -g ionic 或者合成一句统一安装 sudo npm install -g cordova ionic 7、创建项目 1ionic start firstIonicProjectForIos [tabs][blank][sidememu] 8、浏览器中运行项目（调试项目） cd firstIonicProjectForIosionic serve(自动在afai浏览器中打开) 9、模拟器中运行项目 因为apple开发的证书限制我们在没有申请购买apple账号的情况下，使用虚拟机来部署我们的应用，在部署之前需要使用npm安装一个ios-sim插件用来调用模拟器的，执行命令： 1sudo npm install -g ios-sim 然后执行 1ionic platform add ios （添加ios平台）ionic build ios 开始编译项目，编译完成之后用Xcode打开开发目录下platform-&gt;ios-&gt;myIonic.xcodeproj的项目文件，Xcode中选择要运行的虚拟机版本并执行快捷键cmd+R运行虚拟机，虚拟机打开后会自动运行你应用。 当然你也可以使用命令： 1ionic emulate ios(在ios模拟器中打开)/ionic run ios(我的报错了) PS: 为什么不用run ios 命令直接启动虚拟机呢，因为我的环境下执行run会报错，虚拟机会打开但是无法运行程序，找了半天解决解决方案没有结果，索性直接用Xcode了，效果是一样的 10、打包项目 能使用Ionic来开发app的很可能对Ios和android的app打包发布流程不是很熟悉，我这里简单说明下： ionic build android命令执行完成之后会在项目目录/platforms/android/build/outputs/apk目录下面生成.apk文件。 但是ionic build ios命令执行完成之后不会生成.ipa文件，只会在项目目录/platform/os目录下生成.xcodeproj文件，这个文件需要借助Xcode才能将其打包成.ipa文件。 因此接下来的任务就成了使用Xcode打包.xcodeproj成为.ipa的事情了。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova插件使用（一套流程适用于每个插件使用）]]></title>
    <url>%2F2016%2F09%2F21%2Fcordova%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%E5%A5%97%E6%B5%81%E7%A8%8B%E9%80%82%E7%94%A8%E4%BA%8E%E6%AF%8F%E4%B8%AA%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[例子：iOS状态栏的控制是这么实现的：访问http://plugins.cordova.io/, 您可以在其中搜索cordova插件，例如我搜下statusbar， 会发现有两个插件。其中下面的名字貌似更官方一点，我们就选择这个作为我们需要的插件。插件的安装很简单。我们需要的只是插件的ID, 也就是cordova-plugin-statusbar. 然后打开终端，然后到cd到自己的项目根目录，输入或粘贴如下代码： 1cordova plugin add cordova-plugin-statusbar 回车，稍等片刻会有类似下面的提示：statusbar安装代码以及提示 说明安装成功。虽说安装是成功了，但到底该如何使用呢？一般这种插件都会在GitHub上开源，Google或Github上搜索cordova-plugin-statusbar，很快我们就会找到这个插件的Github地址 点击进入，众API们引入眼帘，好像黑夜看到了曙光，屌丝看到了女神…… 方法如下： StatusBar.styleDefault 状态栏默认样式，也就是电池信号黑色； StatusBar.styleLightContent 状态栏内容浅色，貌似就是白色，适合深色背景； StatusBar.styleBlackTranslucent 状态栏黑色半透明，我测了下，跟上面一样的效果，电池时间都是白色的，适合深色背景； StatusBar.styleBlackOpaque 状态栏黑色不透明。我测了下，还是白色的，跟上面一样，适合深色背景； StatusBar.hide 状态栏隐藏； StatusBar.show 状态栏显示；只要你使用了Cordova的插件（相机啊，地址位置等），你就得调用自动生成的cordova.js. 1&lt;script src="cordova.js"&gt;&lt;/script&gt; 然后，再你自己的JS中，使用类似StatusBar.hide()就可以隐藏状态栏啦！或者使用StatusBar.styleLightContent()让状态栏从黑人变成白人 其他非官方插件的使用也是类似上面的步骤。]]></content>
      <categories>
        <category>Ionic2</category>
        <category>cordova</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic run android错误error gradle line 64]]></title>
    <url>%2F2016%2F07%2F23%2FIonic%20run%20android%E9%94%99%E8%AF%AFerror%20gradle%20line%2064%20%2F</url>
    <content type="text"><![CDATA[错误提示如下： FAILURE: Build failed with an exception. Where:Script ‘C:\Users\Jay\testproject\platforms\android\CordovaLib\cordova.gradle’ line: 64 What went wrong:A problem occurred evaluating root project ‘android’.No installed build tools found. Please install the Android build tools version19.1.0 or higher. Try:Run with –stacktrace option to get the stack trace. Run with –info or –debugoption to get more log output. 解决方法： I had the same problem and this is how I fixed it. I had the build-tools version 20 installed but still was getting this error:No installed build tools found. Please install the Android build tools version 19.1.0 or higher.So I created a directory named 20 within build-tools directory, and copied all the files from sdk\build-tools\android-4.4W* to sdk\build-tools\20. The problem was fixed! 根据国外友人的提示，这是由于Android tools的问题，升级Android build tools到最新的版本即可解决问题。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic的build命令下载gradle-2.2.1-all.zip卡顿问题]]></title>
    <url>%2F2016%2F07%2F22%2FIonic%E7%9A%84build%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BDgradle-2.2.1-all.zip%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一次使用ionic build Android命令，会自动下载gradle-2.2.1-all.zip，这时候会发现进度超慢 此问题因为需要连接国外网站下载，网络不稳定的原因。 解决方法： 1、先下载好gradle-2.2.1-all.zip包，放在myApp\platforms\android\gradle文件夹下 2、打开myApp\platforms\android\cordova\lib\builders\GradleBuilder.js文件 3、找到CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL，如下图所示 4、在DOS下载先设置CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL环境变量set CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL=../gradle-2.2.1-all.zip]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Android</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
</search>