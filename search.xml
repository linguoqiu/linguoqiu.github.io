<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android自定义控件及属性]]></title>
    <url>%2F2017%2F05%2F31%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%8F%8A%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[主要讲解Android如何创建一个简单的自定义控件和控件属性 1.创建一个类继承至TextView,RelativeLayout等View类这里以RelativeLayout类为讲解,创建一个SettingItemView类继承RelativeLayout，并重写相应的构造函数，具体见以下代码 123456789101112131415161718public class SettingItemView extends RelativeLayout &#123; //使用在通过java代码创建控件 public SettingItemView(Context context) &#123; this(context,null); &#125; //由系统调用（带属性+上下文环境的构造方法） public SettingItemView(Context context, AttributeSet attrs) &#123; this(context, attrs,0); &#125; //由系统调用（带属性+上下文环境+布局文件中定义样式文件的构造方法） public SettingItemView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); //代码实现 //xml---&gt;view 将设置界面的一个条目转换成view对象 //this参数的意思是：将加载到view的布局挂载在这个SettingItemView类上 View view = View.inflate(context, R.layout.setting_item_view, this); &#125;&#125; 2.编写xml布局文件，加入相应的组件新建一个 setting_item_view的xml布局文件 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="5dp" &gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#000" android:textSize="18sp" /&gt; &lt;TextView android:id="@+id/tv_des" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@id/tv_title" android:textColor="#000" android:textSize="18sp" /&gt; &lt;!-- 让当前的checkbox不能被点击 和获取焦点,既不能响应事件 --&gt; &lt;CheckBox android:id="@+id/cb_box" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_centerVertical="true" android:clickable="false" android:focusable="false" android:focusableInTouchMode="false" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:layout_below="@id/tv_des" android:layout_marginTop="8dp" android:background="#000" /&gt;&lt;/RelativeLayout&gt; 3.在其他布局文件中使用此自定义控件使用方法如下代码： 标签名字要指向自定义控件类的全路径 12345&lt;com.****.*****.view.SettingItemView android:id="@+id/siv_update" android:layout_width="match_parent" android:layout_height="wrap_content"&gt;&lt;/com.ntlafa.mobilesafe.view.SettingItemView&gt; 4.自定义属性4.1.查看源码,参考andorid定义属性时候的做法sdk所在目录\platforms\android-16\data\res\values\attrs.xml &lt;resource&gt; &lt;declare-styleable name=&quot;TextView&quot;&gt; &lt;attr name=&quot;text&quot; format=&quot;string&quot;/&gt; &lt;/declare-styleable&gt; &lt;resource&gt; 4.2.给SettingItemView定义属性,创建一个xml：工程res\values\attrs.xml定义以下的属性： name为需要为哪个自定义控件类添加的，就写哪个类的全类名 &lt;resource&gt; &lt;declare-styleable name=&quot;SettingItemView全类名&quot;&gt; &lt;attr name=&quot;destitle&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;desoff&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;deson&quot; format=&quot;string&quot;/&gt; &lt;/declare-styleable&gt; &lt;resource&gt; 4.3.自定义属性的使用定义名空间namespace myAttr替换掉原有android，比如下面的代码： xmlns:myAttr=***** myAttr:destitle=&quot;自定义属性值&quot;； com.****.*****（项目的包名）必须这样编写,替换掉了android,代表当前应用自定义属性， 例如：xmlns:myAttr=&quot;http://schemas.android.com/apk/res/com.****.*****&quot; &lt;com.****.*****.view.SettingItemView xmlns:myAttr=&quot;http://schemas.android.com/apk/res/com.****.*****&quot; android:id=&quot;@+id/siv_update&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; myAttr:destitle=&quot;自定义属性值&quot; myAttr:desoff=&quot;自定义属性值&quot; myAttr:deson=&quot;自定义属性值&quot;&gt; 4.4.获取属性值已经自定义好的属性如下有3个： myAttr:destitle=&quot;自定义属性值&quot; myAttr:desoff=&quot;自定义属性值&quot; myAttr:deson=&quot;自定义属性值&quot; 可以从构造函数的参数中去获取属性，如下代码： 12345678910111213private static final String NAMESPACE = "http://schemas.android.com/apk/res/com.****.*****"; //由系统调用（带属性+上下文环境+布局文件中定义样式文件的构造方法） public SettingItemView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); //代码实现 //xml---&gt;view 将设置界面的一个条目转换成view对象 //this参数的意思是：将加载到view的布局挂载在这个SettingItemView类上 View view = View.inflate(context, R.layout.setting_item_view, this); //通过属性名称&amp;名空间获取属性 mDestitle = attrs.getAttributeValue(NAMESPACE, "destitle"); mDesoff = attrs.getAttributeValue(NAMESPACE, "desoff"); mDeson = attrs.getAttributeValue(NAMESPACE, "deson"); &#125; 这样就可以拿到属性值，并给自定义控件使用了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义对话框]]></title>
    <url>%2F2017%2F05%2F30%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[在Android中自定义对话框的方法 创建一个对话框12Builder builder = new AlertDialog.Builder(this);final AlertDialog dialog = builder.create(); 创建一个View对象，并从xml中加载xml代码省略，和正常的layout一样 12//view是由自己编写的xml转换成view对象xml-----&gt;viewfinal View view = View.inflate(this, R.layout.dialog_confirm_psd, null); 展示对话框12345//让对话框显示一个自己定义的对话框界面效果 //dialog.setView(view); //使用可以设置内边距的setView，为了兼容低版本,使用以下方法 dialog.setView(view, 0, 0, 0, 0); dialog.show(); 最后在view下初始化相应的UI12345678910111213141516//需要在view下findViewById，不然找的是HomeActivity的View控件 Button bt_submit = (Button)view.findViewById(R.id.bt_submit); Button bt_cancel = (Button)view.findViewById(R.id.bt_cancel); bt_submit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); //取消按钮的点击事件 bt_cancel.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //对话框消失 dialog.dismiss(); &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>对话框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 事件分发机制]]></title>
    <url>%2F2017%2F05%2F23%2FAndroid%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[android开发过程中发现如果viewgrounp和view都有点击事件或者其他事件的话，只会相应view的事件，不会像js一样同时触发，通过查找资料，发现此文章很深入简出的解释了Android 事件分发机制，并根据实际做了下小试验。参考 “图解 Android 事件分发机制”http://www.jianshu.com/p/e99b5e8bd67b 创建一个Activity，在Activity下创建一个线性布局LinearLayout（viewgroup），在LinearLayout下创建一个checkbox。 为LinearLayout和checkbox添加点击事件后，如果在LinearLayout上点击了，LinearLayout的点击事件响应，如果在checkbox范围内点击了，会响应checkbox的点击事件 设置checkbox的点击事件失效后，发现如果在checkbox范围内点击，也是LinearLayout的点击事件响应 android:clickable=”false” android:focusable=”false” 根据参考文章和实际的情况了解， Android 事件响应的默认流程： 最先由Activity对应布局文件捕捉到点击事件。 事件默认会分发给最下层的view进行响应。 如最下层的view无法响应，事件将逐层返回给上层去响应。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2升级到Ionic3及配置懒加载]]></title>
    <url>%2F2017%2F05%2F19%2FIonic2%E5%8D%87%E7%BA%A7%E5%88%B0Ionic3%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Ionic3出来也有一段时间，相信已趋于稳定，趁着这段时间不太忙，把现有项目从Ionic2升级到Ionic3最新版本。并试着配置使用下新特性lazyload Ionic2升级到Ionic3 注意，此步只适合现有项目升级使用，如果是新项目，直接ionic-cli 创建项目就好了 1、升级Ionic环境npm update -g ionic 升级到最新的CLi版本 3.1.2 如果升级过程有问题的话，试着升级node.js到最新版本，遇到问题请自行解决。此步不在本文讨论内 2、更新根目录下的 package.json文件更新的部分如下：（可上官方github查看更新部分，因为现在最新版本是3.2.0，本文采用了此配置） “dependencies”: { “@angular/common”: “4.1.0”, “@angular/compiler”: “4.1.0”, “@angular/compiler-cli”: “4.1.0”, “@angular/core”: “4.1.0”, “@angular/forms”: “4.1.0”, “@angular/http”: “4.1.0”, “@angular/platform-browser”: “4.1.0”, “@angular/platform-browser-dynamic”: “4.1.0”, “@ionic-native/core”: “3.6.1”, “@ionic-native/splash-screen”: “3.6.1”, “@ionic-native/status-bar”: “3.6.1”, “@ionic/storage”: “2.0.1”, “ionic-angular”: “3.2.1”, “ionicons”: “3.0.0”, “rxjs”: “5.1.1”, “sw-toolbox”: “3.6.0”, “zone.js”: “0.8.10”},“devDependencies”: { “@ionic/app-scripts”: “1.3.7”, “typescript”: “2.2.1”} 3、在app/app.module.ts文件中引入BrowserModule1import &#123; BrowserModule &#125; from '@angular/platform-browser'; 并且在这里写入下面代码： 1234imports: [ BrowserModule, IonicModule.forRoot(MyApp)], 如果你使用了http的话，还需要app/app.module.ts文件引入HttpModule： 12345678import &#123; HttpModule &#125; from '@angular/http';//在imports这里加入HttpModuleimports: [ BrowserModule, HttpModule, IonicModule.forRoot(MyApp)], 4、删除根目录下的node_modules文件夹，并重新安装插件在项目根目录下执行以下代码 1npm install 4、运行，测试，build运行在浏览器上 1ionic serve 因为ionic3改动的比较多，比如slides等都有改动，如果出错的话，根据提示自行修复，如没意外的话可以下一步build 因为更新了ionic-cli，好像指令也更新了？ 用法不同 build: 1ionic cordova build android 根据提示进行build，如下图： build完成后，可以真机调试，到此就完成了升级。 升级后发现一个好处，根据官方的说法，升级后，size得到了进一步的缩小 Upgrading to Ionic Native 3.x will result in a smaller bundle size. With Ionic Native 3, native functionality was moved from static methods to using Angular injectables. 我根据对比升级后和升级前的main.js的大小，发现的确变小了，由原来的1760kb变为1017kb，可喜可贺啊。 Ionic3配置懒加载 Ionic3使用的懒加载，需要为每个page都配置module，并且改动的地方比较多，而且好像还不兼容rollup，如在ionic2升级上来的，根据实际需求决定是否要使用到此特性了。 注意：如果之前使用了DeepLinkConfig请先删除，因为要在每个页面添加IonicPage修饰符 1、为需要添加懒加载的组件（页面）添加module.ts以carForOnline.ts为例子： 在此ts当前的目录下新建module 注意：务必要与懒加载的ts保持同名，如page的名字叫carForOnline.ts ，新建的module就是carForOnline.module.ts,否者serve时会出以下报错 新建好后，为此module添加如下代码： 123456789101112131415import &#123; NgModule &#125; from '@angular/core';import &#123; CarForOnLinePage &#125; from './carForOnLine';//注意务必要带上./，否者会报运行时错误import &#123; IonicPageModule &#125; from 'ionic-angular';@NgModule(&#123; declarations: [ CarForOnLinePage //ts的className ], imports: [ IonicPageModule.forChild(CarForOnLinePage),//ts的className ], entryComponents: [ CarForOnLinePage //ts的className ]&#125;)export class carForOnLineModule &#123;&#125; 2、为Page添加注解carForOnline.ts 在@Component上面加上如下代码： 123456789101112import &#123; IonicPage &#125; from 'ionic-angular';@IonicPage(&#123; name: 'CarForOnLinePage',//设置自己想要的名字，push和pop中可以代替class Name segment: 'CarForOnLine',//设置deep link，如不设置，默认是classname //defaultHistory: ['list'],//设置默认要返回的page priority: 'off',//属性有: "high", "low", and "off" 默认low，设置预加载模式：高&gt;低&gt;关闭&#125;)@Component(&#123; selector: 'page-carForOnLine', templateUrl: 'carForOnLine.html' 3、删除 app.modules和所有其他Ts文件对此ts的引用删除 app.modules如下代码： 1import &#123; CarForOnLinePage &#125; from '../pages/carForOnLine/carForOnLine'; 其他ts引用到此page的，都需要删除，另外 app.modules的declarations和entryComponents下的CarForOnLinePage也要删除。 4、使用 CarForOnLinePage跳转到此CarForOnLinePage的方式有: 4.1、使用nav 1this.navCtrl.push('CarForOnLinePage');//参数是字符串，如果没name默认就是类名，否者则是IonicPage的参数 name 4.2、使用路由 http://localhost:8100/#/some-path some-path为IonicPage的参数 segment 所以之前使用CarForOnLinePage的地方需修改为： 123456//修改前，使用的是类类型this.navCtrl.push(CarForOnLinePage);//修改后，使用的是字符串类型this.navCtrl.push("CarForOnLinePage"); 5、如有使用到pipe或者自定义组件的，需要将pipe或者自定义组件统一到各自的module中，并在app.module和相应懒加载组件的module中加入引用 因为懒加载页面归到相应的module中，并从app.module中脱离了出来，所以懒加载的页面无法识别到pipe和自定义组件，同时相应的pipe和组件不能被2个module declarations。故需要加入到相应的module中，并在app.module和相应懒加载组件的module中import。 以pipe为例子(本项目把所有pipe放置到一个module中)： 在pipe文件夹下新建pipe.module.ts ，写入代码如下图： 删除app.module中所有pipe的引用，并在app.module和相应的page.module引用pipeModule 6、运行、测试现在可以进行serve，测试是否完成 如运行无错误，在www/build下生成这样的js，证明懒加载成功： 注意事项 1.每个lazy page 都对应一个module，并且需要同在一个目录下，相同的命名+.module. 2.如果使用了摇树优化(rollup)，则无法使用懒加载，即不能使用IonicPage的priority属性，否则会出现System is not define的错误，如图： 加上rollup的build后的文件大小会比用lazy的稍微小一点，看实际需求选择是要rollup或者懒加载 3.关于IonicPage的使用，如设置name，路径，返回页面，懒加载模式等详细情况，参考官网的api-IonicPage]]></content>
      <categories>
        <category>Ionic2</category>
        <category>Ionic3</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Ionic3</tag>
        <tag>lazy load</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2使用Slides的loop属性后点击事件失效bug]]></title>
    <url>%2F2017%2F05%2F15%2FIonic2%E4%BD%BF%E7%94%A8Slides%E7%9A%84loop%E5%B1%9E%E6%80%A7%E5%90%8E%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%A4%B1%E6%95%88bug%2F</url>
    <content type="text"><![CDATA[问题描述：Ionic2使用Slides的loop=’true’属性后，从slide第一页滑动到最后一页，或者最后一页滑动到第一页，点击事件会失效。 问题原因：只要设置了loop=’true’ ，Slide会默认复制第一页和最后一页，分别放在最后一页后和第一页前，达到循环的效果。由于dom代码clone的原因导致点击事件失效 问题解决：为第一页和最后一页的标签加上class，在dom加载完成后对第一页和最后一页加上事件即可。注意：因为clone后，会有2个标签有相同的class，注意区分，还需要阻止事件冒泡 html：1234&lt;ion-slides #ionSlides loop="true" autoplay="3000" pager id="indexSlides" &gt; &lt;ion-slide&gt;&lt;div class="toReport"&gt;&lt;img src=""/&gt;&lt;/div&gt;&lt;/ion-slide&gt; &lt;ion-slide&gt;&lt;div class="toBusines"&gt;&lt;img src=""/&gt;&lt;/div&gt;&lt;/ion-slide&gt;&lt;/ion-slides&gt; TS：123let toReportBtn:any = document.getElementsByClassName("toReport"); toReportBtn[0].addEventListener("click", (e)=&gt;&#123;this.pushToReport();e.stopImmediatePropagation()&#125;); toReportBtn[1].addEventListener("click", (e)=&gt;&#123;this.pushToReport();e.stopImmediatePropagation()&#125;);]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Slides</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2自定义遮罩层和相关注意事项]]></title>
    <url>%2F2017%2F05%2F04%2FIonic2%E8%87%AA%E5%AE%9A%E4%B9%89%E9%81%AE%E7%BD%A9%E5%B1%82%E5%92%8C%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20%2F</url>
    <content type="text"><![CDATA[1、自定义遮罩层步骤1.1先创建一个展示框，在遮罩层之上123&lt;div class="aboutPage-isShowDiv" *ngIf="isShow"&gt; &lt;h1&gt;放内容&lt;/h1&gt; &lt;/div&gt; 1.2根据alert或者其他组件的样式，抽取ion-backdrop标签出来使用123&lt;div *ngIf="isShow" class="backdrop-div" (click)="backdropclick($event)" ontouchmove="event.preventDefault();event.stopPropagation();"&gt; &lt;ion-backdrop disable-activated role="presentation" tappable style="opacity: 0.5; transition-delay: initial; transition-property: none;"&gt;&lt;/ion-backdrop&gt;&lt;/div&gt; 并为组件添加点击事件（阻止冒泡） 12345678910//遮挡层点击事件 backdropclick(e)&#123; //判断点击的是否为遮罩层，是的话隐藏遮罩层 if(e.srcElement.className != 'itemClass')&#123; this.isShow = false; &#125; //隐藏滚动条 this.hiddenscroll(); e.stopPropagation(); &#125; 并为遮罩层添加触摸事件（阻止冒泡、阻止默认事件 ontouchmove=”event.preventDefault();event.stopPropagation();”） 到此，就完成了Ionic2自定义的遮罩层 2.注意事项2.1 在ios手机上遮罩层能滑动解决方法：为遮罩层添加触摸事件，阻止默认事件，阻止冒泡，另外如果样式有些出入的话，还需要微调一下。 2.2 ios上弹出框上有滑动的列表的话，也会带动底层的列表滑动解决方法： 除了给遮罩层添加触摸事件外，还需在弹出框展示的时候隐藏滚动条（设置overflow=’hidden’），恢复时恢复滚动条即可 12&lt;ion-content id="aboutContent"&gt;&lt;/ion-content&gt; 123456789101112//弹出下拉框时，取消scrollhiddenscroll()&#123; //获取当前组件的ID let aboutContent = document.querySelector(&quot;#aboutContent&quot;); //获取当前组件下的scroll-content元素 let scroll:any = aboutContent.querySelector(&quot;.scroll-content&quot;); if(this.isShow)&#123; scroll.style.overflow=&apos;hidden&apos;; &#125;else &#123; scroll.style.overflow=&apos;&apos;; &#125;&#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>遮罩层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2使用百度地图和html5 geolocation的一些注意事项]]></title>
    <url>%2F2017%2F05%2F04%2FIonic2%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%92%8Chtml5%20geolocation%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[1、完美解决window.navigator.geolocation.getCurrentPosition，在IOS10系统中无法定位问题 目前由于许多用户都将电话升级到了IOS系统，苹果的iOS 10已经正式对外推送，相信很多用户已经更新到了最新的系统。然而，如果web站没有及时支持https协议的话，当很多用户在iOS 10下访问很多网站时，会发现都无法进行正常精确定位，导致部分网站的周边推荐服务无法正常使用。为何在iOS 10下无法获取当前位置信息？这是因为在iOS 10中，苹果对webkit定位权限进行了修改，所有定位请求的页面必须是https协议的。如果是非https网页，在http协议下通过html5原生定位接口会返回错误，也就是无法正常定位到用户的具体位置，而已经支持https的网站则不会受影响。 目前提供的解决方案：1、将网站的http设置为Https。2、通过第三方解决，也就是调用百度地图或者其他地图的定位功能进行定位。调用百度地图方法如下： 12345678910111213141516171819202122232425//获取本机的地址let geolocation = new BMap.Geolocation();geolocation.getCurrentPosition((position)=&gt;&#123; //0代表调用成功，具体状态可见百度地图api if(geolocation.getStatus() == 0)&#123; //经度 let longitude =position.longitude; //纬度 let latitude = position.latitude; let pPoint = new BMap.Point(longitude,latitude); let heading = 0; if(position.heading !=null &amp;&amp; position.heading != '')&#123; heading = position.heading; &#125; let icon = new BMap.Symbol(BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW, &#123; scale: 2, strokeWeight: 1, rotation: heading,//顺时针旋转30度 fillColor: '#1794f6', fillOpacity: 0.8 &#125;); &#125;else &#123; console.log(position); &#125; 2、Ionic2的组件使用百度地图、百度地图矢量的方法Ionic2使用百度地图或者其他地图时除了在index.html引入js外，还需要在相应需要使用的ts文件上加上声明： 12declare var BMap;declare var BMap_Symbol_SHAPE_FORWARD_CLOSED_ARROW; 同理，如果需要使用到百度地图的矢量，也要加上声明，如上。 如果多个组件使用到的话，可以在declarations.d.ts文件上全局声明。引入其他js如echart.js等方法雷同]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>geolocation</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2创建一个自定义pipe实现千分位号]]></title>
    <url>%2F2017%2F04%2F09%2FIonic2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89pipe%E5%AE%9E%E7%8E%B0%E5%8D%83%E5%88%86%E4%BD%8D%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[1、在src目录下创建一个pipe目录用于存放自定义pipe，然后创建一个pipe |–src |–pipe *.ts 2、在ts文件里面写pipe的逻辑1234567891011121314151617181920import &#123; Pipe, PipeTransform &#125; from '@angular/core';/* * Raise the value exponentially * Takes an exponent argument that defaults to 1. * Usage: * value | exponentialStrength:exponent * Example: * &#123;&#123; 2 | exponentialStrength:10&#125;&#125; * formats to: 1024 * 将number转换为千分位的字符串 */@Pipe(&#123;name: 'toNumber'&#125;)export class ToNumberPipe implements PipeTransform &#123; //实现了PipeTransform类，实现transform方法，当html使用了toNumber的管道，会自动调用此方法 transform(input:number): string &#123; //这里可以带多个参数，第一个参数默认是原始数据，这里是指 //amount、total 、debt 、overdue ，见下html代码 return input.toString().replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ",");//转为千分位的正则表达式 &#125;&#125; 3、在app.modules.ts中import这个ts文件，然后只需在declarations中声明。4、在需要的Html模版中使用（不需要引入）123456&lt;ul&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].amount | toNumber&#125;&#125;辆&lt;/li&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].total | toNumber&#125;&#125;元&lt;/li&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].debt | toNumber&#125;&#125;辆&lt;/li&gt; &lt;li&gt;&#123;&#123;professionItem.list[0].overdue | toNumber&#125;&#125;元&lt;/li&gt;&lt;/ul&gt; 这样就完成了，amount等数据会传入到transform方法，然后返回的数据展示在li上。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>pipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Ionic2\Angular2使用http的一些坑]]></title>
    <url>%2F2017%2F04%2F09%2F%E5%85%B3%E4%BA%8EIonic2Angular2%E4%BD%BF%E7%94%A8http%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1、服务器接收key=value&amp;key=value类型的值，但服务器无法获取到Post请求的body的值 描述：使用url?key=value&amp;key=value的形式可以正常请求到参数，但是把参数放入到body后，服务器估计获取到信息但无法正确解析 解决：1、body要为字符串，格式：‘key=value&amp;key=value’2、然后发送http请求的时候需要设置下‘Content-Type’: ‘application/x-www-form-urlencoded; charset=UTF-8’ 2、发送登录请求给服务器后，服务器返回cookie，里面含有seesionId，但无法获取到cookie，也无法发送cookie描述：使用angular的post请求后，服务器返回cookie，如下图 但是浏览器中看不到有cookie，也无法获取到这个session值，手动设置cookie，下次发送post时，也不会带上cookie。网上查找，说需要在post请求的option中加上： 1this.http.get('http://my.domain.com/request', &#123; withCredentials: true &#125;) 设置后发现会出现跨域的问题，但已经有cookie存到本地。最后发现使用的googole的插件Allow-Control-Allow-Origin 虽然能进行跨域，但是无法存储和发送cookie 解决：1、禁用了Allow-Control-Allow-Origin2、在本机部署nginx进行跨域，问题解决。可以正常从服务器获取cookie，并发送cookienginx配置：]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript关于promise的学习和运行时机]]></title>
    <url>%2F2017%2F04%2F05%2FJavascript%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[本文是个人看了一些Promise资料，对Promise的一些理解 Promise 的含义 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 基本用法最基本的用法 12345678910111213141516//Promise新建后就会立即执行。var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);//Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 还有很多用法，可以参考es6的相关资料 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 Promise.resolve()有四种写法： 1、如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 2、thenable对象指的是具有then方法的对象，然后就立即执行thenable对象的then方法。 3、如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 4、Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。 promise和setTimeout的执行时间实例如下： 1234567891011121314setTimeout(function () &#123; console.log('three');&#125;, 0);//Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2之tabs相关内容和其他一些坑]]></title>
    <url>%2F2017%2F04%2F05%2FIonic2%E4%B9%8Btabs%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E5%92%8C%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1、 ionic2 中隐藏子页面tabs选项卡的三种方法第一种： 隐藏全部子页面的tabs选项界面找到app.module.ts文件 ，修改如下代码 12345imports: [ IonicModule.forRoot(MyApp,&#123; tabsHideOnSubPages: 'true' //隐藏全部子页面tabs &#125;) ], 第二种：隐藏某个子页面的tabs ; 缺点：当子页面使用pop()方法退出时，父页面的任何事件都不响应。 123import&#123; App &#125; from'ionic-angular'; //1.引入App类constructor(privateapp:App) &#123;&#125; //2.声明初始化app对象this.app.getRootNav().push(nextPage); //3.调用this.app.getRootNav() 从根页面跳转就可以了 第三种：隐藏某个子页面的tabs； 缺点：暂无 123456789101112131415161718//当页面进入初始化的时候 letelements = document.querySelectorAll(".tabbar"); if(elements !=null) &#123; Object.keys(elements).map((key) =&gt; &#123; elements[key].style.display ='none'; &#125;); &#125; //当退出页面的时候ionViewWillLeave() &#123; letelements = document.querySelectorAll(".tabbar"); if(elements !=null) &#123; Object.keys(elements).map((key) =&gt; &#123; elements[key].style.display ='flex'; &#125;); &#125;&#125; 2、Ionic2 组件之Tab的基本属性和事件 示例html代码如下: 1&lt;ion-tabs #mainTabs (ionChange)="changeTabs()" color="danger" tabsHighlight="true"&gt; &lt;ion-tab [root]="tab1Root" [rootParams]="homeParams" tabTitle="Home" tabIcon="home"&gt;&lt;/ion-tab&gt; &lt;ion-tab [root]="tab2Root" (ionSelect)="selectFriend()" tabTitle="Friends" tabIcon="aperture" tabBadge="3" tabBadgeStyle="danger"&gt;&lt;/ion-tab&gt; &lt;ion-tab [root]="tab3Root" enabled="false" swipeBackEnabled="true" tabTitle="Contact" tabIcon="contacts"&gt;&lt;/ion-tab&gt; &lt;/ion-tabs&gt; 3、ionic的一些坑1、如何在push页面后隐藏tabbar 在ionicBootstrap中设置tabsHideOnSubPages为true 2、如何设置返回按键文字 在ionicBootstrap中设置backButtonText，如”返回”或”“ 3、如何在page pop后传递参数到前一个页面 a) 使用model来代替push，然后在dismiss方法中传递参数 b) 使用Promise parent: 12345new Promise((resolve, reject) =&gt; &#123; this.nav.push(ChildPage, &#123;resolve: resolve&#125;); &#125;).then(data =&gt; &#123; let value = data["property"]; &#125;); child： 12let resolve = this.navParams.get("resolve"); resolve(&#123;property: value&#125;); 5 . 如何设置button的disabled状态：注意解除disabled状态需要设置绑定变量为null &lt;button disabled=“{{buttonDisabled}}”&gt; this.buttonDisabled = true; this.buttonDisabled = null; 6.如何修改slides的bullet 在slides的option中添加下面两个属性： bulletClass: &quot;my-swiper-pagination-bullet&quot;, bulletActiveClass: &apos;my-swiper-pagination-bullet-active&apos;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>tabs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2实现:下拉刷新和上拉加载]]></title>
    <url>%2F2017%2F04%2F05%2FIonic2%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[下拉刷新：12345678910&lt;ion-content&gt; &lt;ion-refresher (ionRefresh)="doRefresh($event)"&gt; &lt;ion-refresher-content pullingIcon="arrow-dropdown" pullingText="Pull to refresh" refreshingSpinner="circles" refreshingText="Refreshing..."&gt; &lt;/ion-refresher-content&gt; &lt;/ion-refresher&gt;&lt;/ion-content&gt; TypeScript： 12345678910111213141516@Component(&#123;...&#125;) export class NewsFeedPage &#123; items = []; doRefresh(refresher) &#123; console.log(&apos;Begin async operation&apos;, refresher); setTimeout(() =&gt; &#123; this.items = []; for (var i = 0; i &lt; 30; i++) &#123; this.items.push( this.items.length ); &#125; console.log(&apos;Async operation has ended&apos;); refresher.complete(); &#125;, 2000); &#125; &#125; 上拉加载：1234567891011121314&lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-item *ngFor="let i of items"&gt;&#123;&#123;i&#125;&#125;&lt;/ion-item&gt; &lt;/ion-list&gt; &lt;ion-infinite-scroll (ionInfinite)="doInfinite($event)"&gt; &lt;ion-infinite-scroll-content loadingSpinner="bubbles" loadingText="Loading more data..."&gt; &lt;/ion-infinite-scroll-content&gt; &lt;/ion-infinite-scroll&gt;&lt;/ion-content&gt; TypeScript： 123456789101112131415161718192021222324@Component(&#123;...&#125;)export class NewsFeedPage &#123; items = []; constructor() &#123; for (let i = 0; i &lt; 30; i++) &#123; this.items.push( this.items.length ); &#125; &#125; doInfinite(infiniteScroll) &#123; console.log('Begin async operation'); setTimeout(() =&gt; &#123; for (let i = 0; i &lt; 30; i++) &#123; this.items.push( this.items.length ); &#125; console.log('Async operation has ended'); infiniteScroll.complete(); &#125;, 500); &#125;&#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>refesh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2关于Slides的一些坑]]></title>
    <url>%2F2017%2F04%2F05%2FIonic2%E5%85%B3%E4%BA%8ESlides%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[首先，要知道Slides是实际使用的是swiper组件，所以遇到问题也可以查阅swiper相关资料。 通用Html代码 1&lt;ion-slides #ionSlides loop="true" autoplay="3000" pager (ionSlideAutoplayStop)="autoPlay()"&gt; TS: 1@ViewChild('ionSlides') slides; 1、Slides在用户拖拽后，停止自动播放，解决方法：第一种方法： 可以监听 停止自动播放 事件，然后开启自动播放： 12autoPlay()&#123; this.slides.startAutoplay(); 第二种方法： 在启动的时候设置 slides的属性autoplayDisableOnInteraction 为false； 123ionViewDidEnter()&#123; this.slides.autoplayDisableOnInteraction = false; &#125; 2、自动播放的Slides调转到其他页面一定时间后（超过设置的播放时间），再回到此页面，自动播放失效，解决方法如下： 现在页面退出的时候手动停止slides的播放（此步骤必须要有，不然后面的启动无效），在回来页面加载完成的时候启动自动播放，代码如下： 12345678910 //页面进入时启动自动播放 ionViewDidEnter()&#123; this.slides.startAutoplay(); &#125; //页面离开时停止自动播放 ionViewDidLeave()&#123; this.slides.stopAutoplay(); &#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Slides</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中使用MD5进行加密]]></title>
    <url>%2F2017%2F03%2F20%2FJava%E4%B8%AD%E4%BD%BF%E7%94%A8MD5%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[下方的代码可以直接使用在java或者android开发中，当工具类使用。 Java中使用MD5进行加密12345678910111213141516171819202122232425262728293031323334public class Md5Util &#123; /**给指定字符串按照md5算法去加密 * @param psd 需要加密的密码 加盐处理 * @return md5后的字符串 */ public static String encoder(String psd) &#123; try &#123; //加盐，"自定义字符串"可选择复杂点的字符串 psd = psd +"自定义字符串"; //1,指定加密算法类型 MessageDigest digest = MessageDigest.getInstance("MD5"); //2,将需要加密的字符串中转换成byte类型的数组,然后进行随机哈希过程 byte[] bs = digest.digest(psd.getBytes()); //3,循环遍历bs,然后让其生成32位字符串,固定写法 //4,拼接字符串过程 StringBuffer stringBuffer = new StringBuffer(); for (byte b : bs) &#123; int i = b &amp; 0xff; //int类型的i需要转换成16机制字符 String hexString = Integer.toHexString(i); if(hexString.length()&lt;2)&#123; hexString = "0"+hexString; &#125; stringBuffer.append(hexString); &#125; //5,打印测试 System.out.println(stringBuffer.toString()); return stringBuffer.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return ""; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Md5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)Activity的Launch mode详解 singleTask正解]]></title>
    <url>%2F2017%2F03%2F13%2F(%E8%BD%AC)Activity%E7%9A%84Launch%20mode%E8%AF%A6%E8%A7%A3%20singleTask%E6%AD%A3%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文参考了此文http://hi.baidu.com/amauri3389/blog/item/a54475c2a4b2f040b219a86a.html另附 android task与back stack开发文档翻译参见：http://mypyg.iteye.com/blog/919643 http://blog.csdn.net/infsafe/article/details/5666964 Activity有四种加载模式：standard(默认)， singleTop， singleTask和 singleInstance。以下逐一举例说明他们的区别： standard：Activity的默认加载方法，即使某个Activity在Task栈中已经存在，另一个activity通过Intent跳转到该activity，同样会新创建一个实例压入栈中。例如：现在栈的情况为：A B C D，在D这个Activity中通过Intent跳转到D，那么现在的栈情况为： A B C D D 。此时如果栈顶的D通过Intent跳转到B，则栈情况为：A B C D D B。此时如果依次按返回键，D D C B A将会依次弹出栈而显示在界面上。 singleTop：如果某个Activity的Launch mode设置成singleTop，那么当该Activity位于栈顶的时候，再通过Intent跳转到本身这个Activity，则将不会创建一个新的实例压入栈中。例如：现在栈的情况为：A B C D。D的Launch mode设置成了singleTop，那么在D中启动Intent跳转到D，那么将不会新创建一个D的实例压入栈中，此时栈的情况依然为：A B C D。但是如果此时B的模式也是singleTop，D跳转到B，那么则会新建一个B的实例压入栈中，因为此时B不是位于栈顶，此时栈的情况就变成了：A B C D B。 singleTask：如果某个Activity是singleTask模式，那么Task栈中将会只有一个该Activity的实例。例如：现在栈的情况为：A B C D。B的Launch mode为singleTask，此时D通过Intent跳转到B，则栈的情况变成了：A B。而C和D被弹出销毁了，也就是说位于B之上的实例都被销毁了。 关于singleTask这个网上颇有争议，google api说singTask模式只能启动一个task，且总是位于栈底，这个也不是完全正确 分2种情况： 1、如果在同一个应用(apk)中使用singleTask，刚不在栈底，对应于下面的情况一 2、如果从不同应用启动一个singleTask的activity，刚依赖于此activity所在的栈，如果之前没有运行过，则新建栈处于栈底，如果有运行过，则有可能不在栈底，对应于情况二 情况一：如果在本程序中启动singleTask的activity：假设ActivityA是程序的入口，是默认的模式（standard）,ActivityB是singleTask 模式，由ActivityA启动，刚ActivityB不会位于栈底，不是根元素，不会启动新的task，此种情况ActivityB会和ActivityA在一个栈中，位于ActivityA上面 情况二：如果ActivityB由另外一个程序启动：假设apkA是情况一中的应用，apkB是另外一个测试程序，在apkB中启动apkA中的ActivityB，再分两种情况，如果ActivityB未启动过，刚ActivityB会位于栈底，是根元素，会启动新的task；如果ActivityB启动过，则ActivityB保持原来的位置不变，在栈底或者栈顶，移除掉ActivityB之上所有的activity(如果有)，见下图 此图就是保存了activitY所在的栈的情况，按返回键的时候，会首先依次移除掉activitY所在的栈的activity，然后才是activity2的 注意：singleTask模式的Activity不管是位于栈顶还是栈底，再次运行这个Activity时，都会destory掉它上面的Activity来保证整个栈中只有一个自己，切记切记 singleInstance：将Activity压入一个新建的任务栈中。例如：Task栈1的情况为：A B C。C通过Intent跳转到D，而D的Launch mode为singleInstance，则将会新建一个Task栈2。此时Task栈1的情况还是为：A B C。Task栈2的情况为：D。此时屏幕界面显示D的内容，如果这时D又通过Intent跳转到D，则Task栈2中也不会新建一个D的实例，所以两个栈的情况也不会变化。而如果D跳转到C，则栈1的情况变成了：A B C C，因为C的Launch mode为standard，此时如果再按返回键，则栈1变成：A B C。也就是说现在界面还显示C的内容，不是D。 好了，现在有一个问题就是这时这种情况下如果用户点击了Home键，则再也回不到D的即时界面了。如果想解决这个问题，可以为D在Manifest.xml文件中的声明加上： 1234567&lt;intent-filter&gt; &lt;action Android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; 加上这段之后，也就是说该程序中有两个这种声明，另一个就是那个正常的根activity，在打成apk包安装之后，在程序列表中能看到两个图标，但是如果都运行的话，在任务管理器中其实也只有一个。上面的情况点击D的那个图标就能回到它的即时界面（比如一个EditText，以前输入的内容，现在回到之后依然存在）。 PS：intent-filter中 和 两个过滤条件缺一不可才会在程序列表中添加一个图标，图标下的显示文字是android:label设定的字符串。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2中ViewChild与ContentChild的区别]]></title>
    <url>%2F2017%2F02%2F13%2FAngular2%E4%B8%ADViewChild%E4%B8%8EContentChild%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ViewChild官方文档翻译 : 声明一个对子元素的引用。 ViewChild需要一个参数来选择元素。 如果参数是一个类型，一个指令或一个类型的组件将被绑定。 如果参数是一个字符串，字符串被解释为一个选择器。也就是一个元素包含模板变量（如 #child）。 在任何情况下，如果找到多个元素，那么只返回第一个。 这个子元素将在ngAfterViewInit()回调前被赋值。用最通俗的话大概讲解。 ViewChild就是选择元素用的。 ViewChild会在ngAfterViewInit()回调函数之前做完工作，也就是说你不能在构造函数中使用这个元素。 实例见代码 123456789101112131415161718192021222324import &#123;Component, ViewChild, AfterViewInit&#125; from '@angular/core';@Component(&#123; selector: 'my-com', template: '&lt;button&gt;我是一个按钮&lt;/button&gt;'&#125;)export class MyCom&#123;&#125;@Component(&#123; template: '&lt;my-com #myCom&gt;&lt;/my-com&gt;' directives: [MyCom]&#125;)export class MyPage implements AfterViewInit&#123; @ViewChild(MyCom) myComA; @ViewChild('myCom') myComB; public constructor()&#123; console.log(this.myComA);//undefined console.log(this.myComB);//undefined &#125; public ngAfterViewInit()&#123; console.log(this.myComA);//输出MyCom对象 console.log(this.myComB);//输出MyCom对象 console.log(this.myComA == this.myComB);//true &#125;&#125; 好了，估计你已经知道基本的使用方式了 @ViewChild(MyCom) 可以获取到页面中的MyCom类型的组件 @ViewChild(&apos;myCom&apos;) 可以获取到被标记为#myCom的组件 ContentChild 官方文档翻译 : 查询一个内容。内容查询结果将在ngAfterContentInit()回调前完成 不明白不要紧，先往下看： @ViewChildren跟@ViewChild实际上没什么区别，从名字上很容易理解，一个获取一堆子元素，一个获取一个子元素。 @ViewChild(MyCom) 返回的是一个MyCom变量 @ViewChildren(MyCom) 返回的是一个QueryList&lt;MyCom&gt; 为什么突然蹦出个ViewChildren？因为下面老外使用它来解释 stackoverflow上某老外这样解释 The difference between @ViewChildren and @ContentChildren is that @ViewChildren look for elements in Shadow DOM while @ContentChildren look for them in Light DOM. 可翻译为： @ViewChildren和@ContentChildren之间的区别在于， @ViewChildren用于Shadow DOM，而@ContentChildren用于Light DOM 笔者理解： ContentChild用来获取中的元素 见代码： 1234567891011121314151617181920212223242526import &#123;Component, ViewChild, ContentChild&#125; from '@angular/core';//儿子组件@Component(&#123; selector: 'son-com', template: '&lt;h1&gt;im text&lt;/h1&gt;', directives: [MyCom]&#125;)export class SonCom&#123;&#125;//爸爸组件@Component(&#123; selector: 'father-com', template: ' &lt;son-com&gt;&lt;/son-com&gt; &lt;ng-content&gt;&lt;/ng-content&gt; ', directives: [SonCom]&#125;)export class FatherCom implements AfterViewInit&#123; @ViewChild(SonCom) viewCom; @ContentChild(SonCom) contentCom; public ngAfterViewInit()&#123; console.log(this.viewCom); console.log(this.contentCom); &#125;&#125; 最终输出: &lt;father-com&gt; &lt;h1&gt;im text&lt;/h1&gt; &lt;h1&gt;im text&lt;/h1&gt; &lt;/father-com&gt; 然后我们调试后发现，this.viewCom等于第一行&lt; h1/&gt;，this.contentView等于第二行&lt; h1/&gt;]]></content>
      <categories>
        <category>Ionic2</category>
        <category>Angular2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Angular2</tag>
        <tag>ViewChild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery.extend 函数使用详解]]></title>
    <url>%2F2017%2F02%2F13%2FjQuery.extend%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[jQuery的extend扩展方法Jquery的扩展方法extend是我们在写插件的过程中常用的方法，该方法有一些重载原型，在此，我们一起去了解了解。 一、Jquery的扩展方法原型是: extend(dest,src1,src2,src3...); 它的含义是将src1,src2,src3…合并到dest中,返回值为合并后的dest,由此可以看出该方法合并后，是修改了dest的结构的。如果想要得到合并的结果却又不想修改dest的结构，可以如下使用： var newSrc=$.extend({},src1,src2,src3...)//也就是将&quot;{}&quot;作为dest参数。 这样就可以将src1,src2,src3…进行合并，然后将合并结果返回给newSrc了。如下例： var result=$.extend({},{name:&quot;Tom&quot;,age:21},{name:&quot;Jerry&quot;,sex:&quot;Boy&quot;}) 那么合并后的结果 result={name:&quot;Jerry&quot;,age:21,sex:&quot;Boy&quot;} 也就是说后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。 二、省略dest参数 上述的extend方法原型中的dest参数是可以省略的，如果省略了，则该方法就只能有一个src参数，而且是将该src合并到调用extend方法的对象中去，如： 1、$.extend(src) 该方法就是将src合并到jquery的全局对象中去，如： $.extend({ hello:function(){alert(&apos;hello&apos;);} }); 就是将hello方法合并到jquery的全局对象中。 2、$.fn.extend(src)该方法将src合并到jquery的实例对象中去，如: $.fn.extend({ hello:function(){alert(&apos;hello&apos;);} }); 就是将hello方法合并到jquery的实例对象中。 下面例举几个常用的扩展实例： $.extend({net:{}}); 这是在jquery全局对象中扩展一个net命名空间。 $.extend($.net,{ hello:function(){alert(&apos;hello&apos;);} }) 这是将hello方法扩展到之前扩展的Jquery的net命名空间中去。 三、Jquery的extend方法还有一个重载原型：extend(boolean,dest,src1,src2,src3...) 第一个参数boolean代表是否进行深度拷贝，其余参数和前面介绍的一致，什么叫深层拷贝，我们看一个例子： var result=$.extend( true, {}, { name: &quot;John&quot;, location: {city: &quot;Boston&quot;,county:&quot;USA&quot;} }, { last: &quot;Resig&quot;, location: {state: &quot;MA&quot;,county:&quot;China&quot;} } ); 我们可以看出src1中嵌套子对象location:{city:”Boston”},src2中也嵌套子对象location:{state:”MA”},第一个深度拷贝参数为true，那么合并后的结果就是： result={name:&quot;John&quot;,last:&quot;Resig&quot;, location:{city:&quot;Boston&quot;,state:&quot;MA&quot;,county:&quot;China&quot;}} 也就是说它会将src中的嵌套子对象也进行合并，而如果第一个参数boolean为false，我们看看合并的结果是什么，如下： var result=$.extend( false, {}, { name: &quot;John&quot;, location:{city: &quot;Boston&quot;,county:&quot;USA&quot;} }, { last: &quot;Resig&quot;, location: {state: &quot;MA&quot;,county:&quot;China&quot;} } ); 那么合并后的结果就是: result={name:&quot;John&quot;,last:&quot;Resig&quot;,location:{state:&quot;MA&quot;,county:&quot;China&quot;}} 以上就是$.extend()在项目中经常会使用到的一些细节。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android使用xutils时出错The type org.apache.http.HttpResponse cannot be resolved]]></title>
    <url>%2F2017%2F01%2F20%2FAndroid%E4%BD%BF%E7%94%A8xutils%E6%97%B6%E5%87%BA%E9%94%99The%20type%20org.apache.http.HttpResponse%20cannot%20be%20resolved%2F</url>
    <content type="text"><![CDATA[在Android 6.0（API 23）中，Google已经移除了移除了Apache HttpClient相关的类、HttpResponse类。缺失jar包使用HttpResponse等会报错：The type org.apache.http.HttpResponse cannot be resolved. It is indirectly referenced from required 在使用xutils下载服务器资源的时候，在下载成功，获取资源file的时候，出如下的错 解决方法：推荐使用HttpUrlConnection，如果要继续使用需要Apache HttpClient，需要在eclipse下libs里添加org.apache.http.legacy.jar。添加方法如下： 1、Eclipse中 在错误原因上点击ctrl+1，选择Configure build path，或者Project-&gt;Properties-&gt;Java Build Path-&gt;Libraries-&gt;Add Ecternal JARS-&gt;你的SDK目录的/platforms/android-23/optional/org.apache.http.legacy.jar-&gt;ok 2、android studio里在相应的module下的build.gradle中加入：android {useLibrary ‘org.apache.http.legacy’}]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Android</tag>
        <tag>xutils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现的根据经纬度计算地球上两点之间的距离]]></title>
    <url>%2F2016%2F12%2F14%2FJS%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A0%B9%E6%8D%AE%E7%BB%8F%E7%BA%AC%E5%BA%A6%E8%AE%A1%E7%AE%97%E5%9C%B0%E7%90%83%E4%B8%8A%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[最近用到了根据经纬度计算地球表面两点间距离的公式，然后就用JS实现了一下。计算地球表面两点间的距离大概有两种办法。 第一种是默认地球是一个光滑的球面，然后计算任意两点间的距离，这个距离叫做大圆距离(The Great Circle Distance)。 公式如下： 使用JS来实现为： 12345678910111213141516171819202122var EARTH_RADIUS = 6378137.0; //单位M var PI = Math.PI; function getRad(d)&#123; return d*PI/180.0; &#125; /** * caculate the great circle distance * @param &#123;Object&#125; lat1 * @param &#123;Object&#125; lng1 * @param &#123;Object&#125; lat2 * @param &#123;Object&#125; lng2 */ function getGreatCircleDistance(lat1,lng1,lat2,lng2)&#123; var radLat1 = getRad(lat1); var radLat2 = getRad(lat2); var a = radLat1 - radLat2; var b = getRad(lng1) - getRad(lng2); var s = 2*Math.asin(Math.sqrt(Math.pow(Math.sin(a/2),2) + Math.cos(radLat1)*Math.cos(radLat2)*Math.pow(Math.sin(b/2),2))); s = s*EARTH_RADIUS; s = Math.round(s*10000)/10000.0; return s; &#125; 这个公式在大多数情况下比较正确，只有在处理球面上的相对点的时候，会出现问题，有一个修正的公式，因为没有需要，就没有找出来，可以在wiki上查到。 当然，我们都知道，地球其实并不是一个真正的圆球体，而是椭球，所以有了下面的公式： 1234567891011121314151617181920212223242526272829/** * approx distance between two points on earth ellipsoid * @param &#123;Object&#125; lat1 * @param &#123;Object&#125; lng1 * @param &#123;Object&#125; lat2 * @param &#123;Object&#125; lng2 */ function getFlatternDistance(lat1,lng1,lat2,lng2)&#123; var f = getRad((lat1 + lat2)/2); var g = getRad((lat1 - lat2)/2); var l = getRad((lng1 - lng2)/2); var sg = Math.sin(g); var sl = Math.sin(l); var sf = Math.sin(f); var s,c,w,r,d,h1,h2; var a = EARTH_RADIUS; var fl = 1/298.257; sg = sg*sg; sl = sl*sl; sf = sf*sf; s = sg*(1-sl) + (1-sf)*sl; c = (1-sg)*(1-sl) + sf*sl; w = Math.atan(Math.sqrt(s/c)); r = Math.sqrt(s*c)/w; d = 2*w*a; h1 = (3*r -1)/2/c; h2 = (3*r +1)/2/s; return d*(1 + fl*(h1*sf*(1-sg) - h2*(1-sf)*sg)); &#125; 这个公式计算出的结果要比第一个好一些，当然，最后结果的经度实际上还取决于传入的坐标的精度。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic2点击事件感觉到延迟的解决办法]]></title>
    <url>%2F2016%2F12%2F14%2Fionic2%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%84%9F%E8%A7%89%E5%88%B0%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[In general, we recommend only adding (click) events to elements that are normally clickable. This includes &lt; button&gt; and &lt; a&gt; elements. This improves accessibility as a screen reader will be able to tell that the element is clickable.However, you may need to add a (click) event to an element that is not normally clickable. When you do this you may experience a 300ms delay from the time you click the element to the event firing. To remove this delay, you can add the tappable attribute to your element. 1&lt;div tappable (click)="doClick()"&gt;I am clickable!&lt;/div&gt; 一般来说，我们建议您只向通常可点击的元素添加（点击）事件。 这包括&lt; button&gt;和&lt; a&gt;元素。 这提高了可访问性，因为屏幕阅读器将能够告诉该元素是可点击的。 但是，您可能需要向通常不可点击的元素添加（点击）事件。 执行此操作时，您可能会遇到从点击元素到事件触发的300毫秒延迟。 要删除此延迟，可以将tappable属性添加到元素。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>tappable</tag>
        <tag>点击延迟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS、Jquery实现---把后台传过来的时间毫秒数转换成想要的日期格式]]></title>
    <url>%2F2016%2F11%2F03%2FJS%E3%80%81Jquery%E5%AE%9E%E7%8E%B0---%E6%8A%8A%E5%90%8E%E5%8F%B0%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E6%97%B6%E9%97%B4%E6%AF%AB%E7%A7%92%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E6%83%B3%E8%A6%81%E7%9A%84%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[后台传过来的数据 creationTime 在后台是Date类型的 毫秒转换成 05-24 月 日格式的 123456789//获得月日得到日期oTime function getMoth(str)&#123; var oDate = new Date(str), oMonth = oDate.getMonth()+1, oDay = oDate.getDate(), oTime = getzf(oMonth) +'-'+ getzf(oDay);//最后拼接时间 return oTime; &#125;; console.log(getMoth(1465959000));//使用方法 毫秒转换成 年月日+时分秒 格式的 1970-01-18 07:12:39 补0操作： 比如2012-2-2 就会变成 2012-02-02 使用方法： getMyDate(data[i].creationTime); 12345678910111213141516171819//获得年月日 得到日期oTime function getMyDate(str)&#123; var oDate = new Date(str), oYear = oDate.getFullYear(), oMonth = oDate.getMonth()+1, oDay = oDate.getDate(), oHour = oDate.getHours(), oMin = oDate.getMinutes(), oSen = oDate.getSeconds(), oTime = oYear +'-'+ getzf(oMonth) +'-'+ getzf(oDay) +' '+ getzf(oHour) +':'+ getzf(oMin) +':'+getzf(oSen);//最后拼接时间 return oTime; &#125;; //补0操作 function getzf(num)&#123; if(parseInt(num) &lt; 10)&#123; num = '0'+num; &#125; return num; &#125; 毫秒转换成 年月日 时分秒的格式 12345678910111213141516171819/* js由毫秒数得到年月日 使用： (new Date(data[i].creationTime)).Format("yyyy-MM-dd hh:mm:ss.S") */ Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt; &#125;;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular2的http请求返回结果的subcribe注意事项]]></title>
    <url>%2F2016%2F10%2F27%2Fangular2%E7%9A%84http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84subcribe%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[1234567891011121314mData:anythis.monitorSer.getVehicleLonAndLat(vehicleIds) .subscribe( data =&gt; &#123; //将data下的data存放到mData中 this.mData=JSON.parse(data.data); //功能实现 this.init(); &#125;, error =&gt; this.errorMessage = &lt;any&gt;error);//错误处理 subscribe()异步处理，如果需要用返回的数据，在返回函数里面将数据存入成员变量，并作相应的处理]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2可以有两种方式来存储数据，Local Storage和SQLite]]></title>
    <url>%2F2016%2F10%2F27%2FIonic2%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%8CLocal%20Storage%E5%92%8CSQLite%2F</url>
    <content type="text"><![CDATA[Ionic2可以有两种方式来存储数据，Local Storage和SQLiteLocalStorage 因为比较容易访问，所以不适合存比较敏感性的数据 比如可以存储: 用户是否登录的信息. 一些session信息等 具体用法： 进入项目目录：cd MyFirstApp在主页设置一个按钮，点击按钮，获取LocalStorage的数据并打印在控制台 app/pages/home/home.html 在app/pages/home/home.ts中增加一个处理方法： 我们可以通过 this.local = new Storage(LocalStorage); this.local.set(‘isLogin’, false); 来设置并保存isLogin的值 并且通过： this.local.get(‘isLogin’); 来获取isLogin的值 此上方法目前使用较少，可以用HTML5的LocalStorage代替 localstorage.setItem(‘…’,’…’); localstorage.getItem(‘…’); localstorage注意事项：1、localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。2、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性3、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换4、localStorage在浏览器的隐私模式下面是不可读取的5、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡6、localStorage不能被爬虫抓取到localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空 SQLite我们还可以通过SQLite来存储数据，通过SQL语句来实现相关存储。 首先我们必须增加一个插件：进入项目目录：cd MyFirstApp 运行：ionic plugin add https://github.com/litehelpers/Cordova-sqlite-storage在app/app.ts中，我们先初始化一些数据库信息： 在app/pages/home/home.html中增加一个按钮和一个Label，点击按钮，将数据库dbname6中people这个表的第一条记录的firstname字段展示出来： app/pages/home/home.html 在app/pages/home/home.ts中增加相应的方法来获取数据库中的数据： 运行：ionic serve -l 点击ShowData按钮：]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Local</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在chrome浏览器上出现此错误ERR_BLOCKED_BY_CLIENT]]></title>
    <url>%2F2016%2F10%2F27%2F%E5%9C%A8chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E5%87%BA%E7%8E%B0%E6%AD%A4%E9%94%99%E8%AF%AFERR_BLOCKED_BY_CLIENT%2F</url>
    <content type="text"><![CDATA[在 chrome浏览器上出现此错误，一般都是安装有拦截广告的插件，把此功能给拦截了 I had faced the similar error, it is basically caused when use the ad blockers.Turn them off, and you run it easily.]]></content>
      <categories>
        <category>Ionic2</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>ERR_BLOCKED_BY_CLIENT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic2(Angular)中使用Rxjs的Observeble]]></title>
    <url>%2F2016%2F10%2F27%2FIonic2(Angular)%E4%B8%AD%E4%BD%BF%E7%94%A8Rxjs%E7%9A%84Observeble%2F</url>
    <content type="text"><![CDATA[如下一样，需要为handleError 添加private ，不加或者为public的话， ionic serve 不会报错，但是ionic build ios 会出错。 12345678910111213private extractData(res: Response) &#123; let body = res.json(); console.info(res.json()); return body|| &#123; &#125;;&#125;private handleError (error: any) &#123; // In a real world app, we might use a remote logging infrastructure // We'd also dig deeper into the error to get a better message let errMsg = (error.message) ? error.message : error.status ? `$&#123;error.status&#125; - $&#123;error.statusText&#125;` : 'Server error'; console.error(errMsg); // log to console instead return Observable.throw(errMsg);&#125;]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Observeble</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序引用fontawesome字体]]></title>
    <url>%2F2016%2F10%2F27%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%95%E7%94%A8fontawesome%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[关于添加字体图标其实跟添加自定义的字体是一样的东西。由于微信小程序不支持本地的路径，但是base64可用,所以我们将通过转为base64使用 前往fontawesome官网下载字体包。 http://fontawesome.dashgame.com/ 打开1中下载的压缩包找到.ttf文件。 将2中的字体文件进行 base64编码 https://transfonter.org/ 可在此网站进行转码，步骤如下 打开3中下载的文件，找到stylesheet.css 打开4中的文件，复制里面的代码到微信小程序中的app.wxss中。 打开1中的文件font-awesome.css,复制里面的css(去掉@font-face部分)到微信小程序中的app.wxss中（接着5中复制内容的后面）。也可以选择font-awesome.min.css,复制的代码如下图所示 在程序中直接引用就可以了。实例代码具体样式的用法，可以到官网查看]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>fontawesome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic2页面的生命周期]]></title>
    <url>%2F2016%2F10%2F27%2Fionic2%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Windows下使用ionic打包与开发IOS程序]]></title>
    <url>%2F2016%2F09%2F21%2F%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8B%E4%BD%BF%E7%94%A8ionic%E6%89%93%E5%8C%85%E4%B8%8E%E5%BC%80%E5%8F%91IOS%E7%A8%8B%E5%BA%8F%20%2F</url>
    <content type="text"><![CDATA[开发iOS程序需要mac本，没的话就只能在虚拟机上安装一个MacOS以下为步骤： 1、安装VMware和Mac OS 参考网上教程 2、ionic开发ios程序 3、安装Xcode 为什么要安装Xcode呢？ ionic开发Android程序都不需要安装eclipse等IDE，只要一个能写CSS，JS ，HTML的IDE就行（Hbuilder，WebStrom，Sublime Text）， 开发完成之后不就执行个ionic platform add android,ionic build android，然后就能生成一个.apk文件，给手机上一安装O了。 ionic开发ios程序就得安装Xcode IDE，这是因为蛋疼的ios程序无法直接使用命令生成，使用命令只能生成.project文件，然后再使用Xcode IDE将.project文件转成.ipa文件，更让人蛋疼的是这个ipa文件居然也不能被直接安装到爱疯上，只能先上传到APP Store，人家审核通过之后，我们再从APP Store上下载。（看到这你可能快疯了，但是没法啊，谁让人家NB呢。好了废话少说了，乖乖安装Xcode吧） 4、安装ionic开发环境 （这个和在windows上安装android开发环境类似） 5、安装Nodejs 百度下载，傻瓜式安装，注意：你现在是Mac本，所以需要下载Nodejs for mac的，别下错了 6、安装cordova,ionic 1234sudo npm install -g cordova sudo npm install -g ionic 或者合成一句统一安装 sudo npm install -g cordova ionic 7、创建项目 1ionic start firstIonicProjectForIos [tabs][blank][sidememu] 8、浏览器中运行项目（调试项目） cd firstIonicProjectForIosionic serve(自动在afai浏览器中打开) 9、模拟器中运行项目 因为apple开发的证书限制我们在没有申请购买apple账号的情况下，使用虚拟机来部署我们的应用，在部署之前需要使用npm安装一个ios-sim插件用来调用模拟器的，执行命令： 1sudo npm install -g ios-sim 然后执行 1ionic platform add ios （添加ios平台）ionic build ios 开始编译项目，编译完成之后用Xcode打开开发目录下platform-&gt;ios-&gt;myIonic.xcodeproj的项目文件，Xcode中选择要运行的虚拟机版本并执行快捷键cmd+R运行虚拟机，虚拟机打开后会自动运行你应用。 当然你也可以使用命令： 1ionic emulate ios(在ios模拟器中打开)/ionic run ios(我的报错了) PS: 为什么不用run ios 命令直接启动虚拟机呢，因为我的环境下执行run会报错，虚拟机会打开但是无法运行程序，找了半天解决解决方案没有结果，索性直接用Xcode了，效果是一样的 10、打包项目 能使用Ionic来开发app的很可能对Ios和android的app打包发布流程不是很熟悉，我这里简单说明下： ionic build android命令执行完成之后会在项目目录/platforms/android/build/outputs/apk目录下面生成.apk文件。 但是ionic build ios命令执行完成之后不会生成.ipa文件，只会在项目目录/platform/os目录下生成.xcodeproj文件，这个文件需要借助Xcode才能将其打包成.ipa文件。 因此接下来的任务就成了使用Xcode打包.xcodeproj成为.ipa的事情了。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova插件使用（一套流程适用于每个插件使用）]]></title>
    <url>%2F2016%2F09%2F21%2Fcordova%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%E5%A5%97%E6%B5%81%E7%A8%8B%E9%80%82%E7%94%A8%E4%BA%8E%E6%AF%8F%E4%B8%AA%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[例子：iOS状态栏的控制是这么实现的：访问http://plugins.cordova.io/, 您可以在其中搜索cordova插件，例如我搜下statusbar， 会发现有两个插件。其中下面的名字貌似更官方一点，我们就选择这个作为我们需要的插件。插件的安装很简单。我们需要的只是插件的ID, 也就是cordova-plugin-statusbar. 然后打开终端，然后到cd到自己的项目根目录，输入或粘贴如下代码： 1cordova plugin add cordova-plugin-statusbar 回车，稍等片刻会有类似下面的提示：statusbar安装代码以及提示 说明安装成功。虽说安装是成功了，但到底该如何使用呢？一般这种插件都会在GitHub上开源，Google或Github上搜索cordova-plugin-statusbar，很快我们就会找到这个插件的Github地址 点击进入，众API们引入眼帘，好像黑夜看到了曙光，屌丝看到了女神…… 方法如下： StatusBar.styleDefault 状态栏默认样式，也就是电池信号黑色； StatusBar.styleLightContent 状态栏内容浅色，貌似就是白色，适合深色背景； StatusBar.styleBlackTranslucent 状态栏黑色半透明，我测了下，跟上面一样的效果，电池时间都是白色的，适合深色背景； StatusBar.styleBlackOpaque 状态栏黑色不透明。我测了下，还是白色的，跟上面一样，适合深色背景； StatusBar.hide 状态栏隐藏； StatusBar.show 状态栏显示；只要你使用了Cordova的插件（相机啊，地址位置等），你就得调用自动生成的cordova.js. 1&lt;script src="cordova.js"&gt;&lt;/script&gt; 然后，再你自己的JS中，使用类似StatusBar.hide()就可以隐藏状态栏啦！或者使用StatusBar.styleLightContent()让状态栏从黑人变成白人 其他非官方插件的使用也是类似上面的步骤。]]></content>
      <categories>
        <category>Ionic2</category>
        <category>cordova</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js计算两个日期之间的天数]]></title>
    <url>%2F2016%2F08%2F24%2FJs%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%A9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[计算两个日期之间的天数： 1234567function test() &#123; alert(duration(new Date(2009, 11, 31), new Date(2010, 0, 10))); alert(duration(new Date(2009, 0, 31), new Date(2009, 1, 10)));&#125;function duration(d1, d2)&#123; return (d2.getTime() - d1.getTime()) / (24 * 60 * 60 * 1000);&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS计算一个月有多少天]]></title>
    <url>%2F2016%2F08%2F24%2FJS%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E6%9C%88%E6%9C%89%E5%A4%9A%E5%B0%91%E5%A4%A9%20%2F</url>
    <content type="text"><![CDATA[JS计算当月有多少天的方法： 12345678910111213function getCountDays() &#123; var curDate = new Date(); /* 获取当前月份 */ var curMonth = curDate.getMonth(); /* 生成实际的月份: 由于curMonth会比实际月份小1, 故需加1 */ curDate.setMonth(curMonth + 1); /* 将日期设置为0, 这里为什么要这样设置, 我不知道原因, 这是从网上学来的 */ curDate.setDate(0); /* 返回当月的天数 */ return curDate.getDate();&#125; //例如, 获取当前月份(现在是8月)的总天数: getCountDays() // 返回31 Javascript的Date.setDate()方法： setDate()方法用来设定日期物件中本地时间的日，也就是每个月中的几号，传入参数是一個1~31的整数。若是传入的值超出当月份的正常范围，setDate()方法也会依据超出的数值进行计算，譬如setDate(0)会让日期变成前一个月的最后一天，setDate(-1)会让日期变成前一個月的倒数第二天。若当月有31天，那setDate(32)会让日期变成下个月的第一天。 Date.setDate()的语法： DateObj.setDate(dayValue) dayValue：传入值，是一个1~31的整数，若是传入的值超出当月份的正常范围，setDate()方法也会依据超出的数值进行计算。 传回值：从1970年1月1日0时0分到该UTC时间经过的毫秒数。 123456789101112&lt;script type="text/javascript"&gt; var mydate = new Date("Mar 31, 2013 21:00:00"); document.writeln(mydate.toLocaleString()); document.writeln("&lt;br/&gt;"); mydate.setDate(0); document.writeln(mydate.toLocaleString()); document.writeln("&lt;br/&gt;"); var mydate2 = new Date("Mar 31, 2013 21:00:00"); mydate2.setDate(32); document.writeln(mydate2.toLocaleString()); document.writeln("&lt;br/&gt;");&lt;/script&gt; Date.setDate()的范例输出： 2013年3月31日 下午9:00:00 2013年2月28日 下午9:00:00 2013年4月1日 下午9:00:00 Date.setDate()的范例说明： 1.设定日期为2013年3月31。 2.使用setDate(0)，日期变为2月28日。 3.设定新日期为2013年3月31。 4.使用setDate(32)，日期变为2013年4月1日。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中在当前日期上追加一天或者获取上一个月和下一个月]]></title>
    <url>%2F2016%2F08%2F24%2FJS%E4%B8%AD%E5%9C%A8%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E4%B8%8A%E8%BF%BD%E5%8A%A0%E4%B8%80%E5%A4%A9%E6%88%96%E8%80%85%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9C%88%E5%92%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%88%2F</url>
    <content type="text"><![CDATA[JS中在当前日期上追加一天Date本来就有setDate()的方法 ，用getDate()出来的数值+1就是加1天 如果大于本月最大天数会自动往下加一个月的 如： &lt;script language=&quot;JavaScript&quot;&gt; var now = new Date(); now.setDate(now.getDate()+1); alert(now); &lt;/script&gt; 获取上一个月或者下一个月的算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162* 获取上一个月 * * @date 格式为yyyy-mm-dd的日期，如：2014-01-25 */ function getPreMonth(date) &#123; var arr = date.split('-'); var year = arr[0]; //获取当前日期的年份 var month = arr[1]; //获取当前日期的月份 var day = arr[2]; //获取当前日期的日 var days = new Date(year, month, 0); days = days.getDate(); //获取当前日期中月的天数 var year2 = year; var month2 = parseInt(month) - 1; if (month2 == 0) &#123; year2 = parseInt(year2) - 1; month2 = 12; &#125; var day2 = day; var days2 = new Date(year2, month2, 0); days2 = days2.getDate(); if (day2 &gt; days2) &#123; day2 = days2; &#125; if (month2 &lt; 10) &#123; month2 = '0' + month2; &#125; var t2 = year2 + '-' + month2 + '-' + day2; return t2; &#125; /** * 获取下一个月 * * @date 格式为yyyy-mm-dd的日期，如：2014-01-25 */ function getNextMonth(date) &#123; var arr = date.split('-'); var year = arr[0]; //获取当前日期的年份 var month = arr[1]; //获取当前日期的月份 var day = arr[2]; //获取当前日期的日 var days = new Date(year, month, 0); days = days.getDate(); //获取当前日期中的月的天数 var year2 = year; var month2 = parseInt(month) + 1; if (month2 == 13) &#123; year2 = parseInt(year2) + 1; month2 = 1; &#125; var day2 = day; var days2 = new Date(year2, month2, 0); days2 = days2.getDate(); if (day2 &gt; days2) &#123; day2 = days2; &#125; if (month2 &lt; 10) &#123; month2 = '0' + month2; &#125; var t2 = year2 + '-' + month2 + '-' + day2; return t2; &#125; //测试 //alert(getPreMonth("2014-01-25")); //alert(getNextMonth("2014-12-25")); 或者另外一种方法： 如果只是要月份 , 就不用跟日期类打交道了..直接算就好了 12345678910111213function getMonths(date1 , date2)&#123; //用-分成数组 date1 = date1.split("-"); date2 = date2.split("-"); //获取年,月数 var year1 = parseInt(date1[0]) , month1 = parseInt(date1[1]) , year2 = parseInt(date2[0]) , month2 = parseInt(date2[1]) , //通过年,月差计算月份差 months = (year2 - year1) * 12 + (month2-month1) + 1; return months; &#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic run android错误error gradle line 64]]></title>
    <url>%2F2016%2F07%2F23%2FIonic%20run%20android%E9%94%99%E8%AF%AFerror%20gradle%20line%2064%20%2F</url>
    <content type="text"><![CDATA[错误提示如下： FAILURE: Build failed with an exception. Where:Script ‘C:\Users\Jay\testproject\platforms\android\CordovaLib\cordova.gradle’ line: 64 What went wrong:A problem occurred evaluating root project ‘android’.No installed build tools found. Please install the Android build tools version19.1.0 or higher. Try:Run with –stacktrace option to get the stack trace. Run with –info or –debugoption to get more log output. 解决方法： I had the same problem and this is how I fixed it. I had the build-tools version 20 installed but still was getting this error:No installed build tools found. Please install the Android build tools version 19.1.0 or higher.So I created a directory named 20 within build-tools directory, and copied all the files from sdk\build-tools\android-4.4W* to sdk\build-tools\20. The problem was fixed! 根据国外友人的提示，这是由于Android tools的问题，升级Android build tools到最新的版本即可解决问题。]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic的build命令下载gradle-2.2.1-all.zip卡顿问题]]></title>
    <url>%2F2016%2F07%2F22%2FIonic%E7%9A%84build%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BDgradle-2.2.1-all.zip%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一次使用ionic build Android命令，会自动下载gradle-2.2.1-all.zip，这时候会发现进度超慢 此问题因为需要连接国外网站下载，网络不稳定的原因。 解决方法： 1、先下载好gradle-2.2.1-all.zip包，放在myApp\platforms\android\gradle文件夹下 2、打开myApp\platforms\android\cordova\lib\builders\GradleBuilder.js文件 3、找到CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL，如下图所示 4、在DOS下载先设置CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL环境变量set CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL=../gradle-2.2.1-all.zip]]></content>
      <categories>
        <category>Ionic2</category>
      </categories>
      <tags>
        <tag>Ionic2</tag>
        <tag>Android</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css伪元素和伪类的区分]]></title>
    <url>%2F2016%2F07%2F10%2Fcss%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[伪类用于向某些选择器添加特殊的效果。伪元素用于将特殊的效果添加到某些选择器。伪类有：:first-child ，:link:，vistited，:hover，:active，:focus，:lang伪元素有：:first-line，:first-letter，:before，:after 使用伪类： 1234567&lt;style&gt; p&gt;i:first-child &#123;color: red&#125;&lt;/style&gt;&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt; 如果我们不使用伪类，而希望达到上述效果，可以这样做： 不使用伪类： 1234567&lt;style&gt; .first-child &#123;color: red&#125;&lt;/style&gt;&lt;p&gt; &lt;i class="first-child"&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt; 即我们给第一个子元素添加一个类，然后定义这个类的样式。 使用为元素： 1234&lt;style&gt; p:first-letter &#123;color: red&#125;&lt;/style&gt;&lt;p&gt;I am stephen lee.&lt;/p&gt; 那么如果我们不使用伪元素，要达到上述效果，应该怎么做呢？ 不使用为元素： 1234&lt;style&gt; .first-letter &#123;color: red&#125;&lt;/style&gt;&lt;p&gt;&lt;span class='first-letter'&gt;I&lt;/span&gt; am stephen lee.&lt;/p&gt; 即我们给第一个字母添加一个 span，然后给 span 增加样式。两者的区别已经出来了。那就是： 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。 伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 CSS3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 :Pseudo-classes //伪类::Pseudo-elements //伪元素 但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>css</tag>
      </tags>
  </entry>
</search>